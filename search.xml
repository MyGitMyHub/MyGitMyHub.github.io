<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[索引器]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E7%B4%A2%E5%BC%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[定义官方定义：索引器允许类或结构的实例就像数组一样进索引。无需显式指定类型或实例成员，即可设置或检索索引值。索引器类似于属性，不同之处在于它们的访问器需要使用参数。 码友定义： 索引器允许类或者结构的实例按照与数组的方式进行索引取值，不同的是索引器的访问是带参数的。 索引器是一种特殊的类成员，它能够让对象以类似数组的方式来存取。 下面来定义一泛型类： 123456789101112131415161718public class SampleCollection&lt;W&gt;&#123; /// &lt;summary&gt; /// 声明一个数据用于存储数据元素 /// &lt;/summary&gt; private W[] arr = new W[100]; /// &lt;summary&gt; /// 定义一个索引器允许客户端代码 /// &lt;/summary&gt; /// &lt;param name=&quot;i&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public W this[int i] &#123; get &#123; return arr[i]; &#125; set &#123; arr[i] = value; &#125; &#125;&#125; 主程序调用：123var stringCollection = new SampleCollection&lt;string&gt;();stringCollection[0] = &quot;Hello World!!&quot;;Console.WriteLine(stringCollection[0]); 使用索引器示例一：用数字索引索引器代码：1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 使用数字索引/// &lt;/summary&gt;public class TempRecord&#123; // 定义 private string[] temps = new string[10] &#123; &quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;七&quot;,&quot;八&quot;,&quot;九&quot;,&quot;十&quot; &#125;; public int Lenght &#123; get &#123; return temps.Length; &#125; &#125; public string this[int index] &#123; get &#123; return temps[index]; &#125; set &#123; temps[index] = value; &#125; &#125;&#125; 调用代码：12345678TempRecord tR = new TempRecord();tR[3] = &quot;叁&quot;;tR[5] = &quot;伍&quot;;for(int i = 0; i&lt;10; i++)&#123; Console.WriteLine(&quot;&#123;0&#125; ====》》》&#123;1&#125;&quot;, i, tR[i]);&#125; 结果：1234567891011Hi Index0 ====》》》一1 ====》》》二2 ====》》》三3 ====》》》叁4 ====》》》五5 ====》》》伍6 ====》》》七7 ====》》》八8 ====》》》九9 ====》》》十 示例二： 使用字符串索引索引器代码：1234567891011121314151617181920212223242526272829303132333435public class DayCollection&#123; // 一个周 string[] days = &#123; &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tues&quot;, &quot;Thurs&quot;, &quot;Fri&quot;, &quot;Sat&quot; &#125;; /// &lt;summary&gt; /// 对比输入的日期，如果是目的就输入 /// &lt;/summary&gt; /// &lt;param name=&quot;testDay&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private int GetDay(string testDay) &#123; for(int j = 0; j &lt; days.Length; j++) &#123; if(days[j] == testDay) &#123; return j; &#125; &#125; throw new ArgumentOutOfRangeException(testDay, &quot;搞错了吧！！&quot;); &#125; /// &lt;summary&gt; /// 只读索引器 /// &lt;/summary&gt; /// &lt;param name=&quot;day&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int this[string day] &#123; get &#123; return (GetDay(day)); &#125; &#125;&#125; 调用代码：12DayCollection dc = new DayCollection();Console.WriteLine(dc[&quot;Tues&quot;]); 调用结果：12 示例三：多个索引器参数]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>索引器</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2Ftemp%2F</url>
    <content type="text"></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppSettings和ConnectionStrings的区别]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2FAppSettings%E5%92%8CConnectionStrings%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[三种配置文件 web.config是web应用程序的配置文件，为web应用程序担相应配置（B/S）。 app.config是桌面端应用程序的配置文件，为桌面应用程序提供相应配置文件。 AppSettings是ASP.Net1.1时期用的。ConnectionStrings是.Net Framework 2.0 新增的 一、 connectionStrings]以下是App.config配置： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5.2&quot; /&gt; &lt;/startup&gt; &lt;connectionStrings&gt; &lt;add name=&quot;ConnStrHello&quot; connectionString=&quot;Data Source=LEIKE;Initial Catalog=SYXT;User ID=sa;Password=sa&quot; providerName=&quot;System.Data.SqlClient&quot; /&gt; &lt;/connectionStrings&gt;&lt;/configuration&gt; 以下是主应用程序调用示例： 123456789101112131415161718using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string cs = ConfigurationManager.ConnectionStrings[&quot;ConnStrHello&quot;].ConnectionString; Console.ReadKey(); &#125; &#125;&#125; 二、 appSettings以下为App.config配置内容： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5.2&quot; /&gt; &lt;/startup&gt; &lt;appSettings&gt; &lt;add key=&quot;mobile&quot; value =&quot;10085&quot;/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 以下为主应用程序调用示例：12345678910111213141516171819using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string sys = ConfigurationManager.AppSettings[&quot;mobile&quot;]; Console.Write(sys); Console.ReadKey(); &#125; &#125;&#125; 三、区别 AppSettings 是在2003中常用的，ConnectionStrins是2005中常用的. 使用ConnectionString的好处： 第一：可将连接字符串加密，使用MS的一个加密工具即可。 第二：可直接邦定的数据源控件，而不必写代码读出来再赋值给控件。 第三：可方便的更换数据库平台，如换为Oracle数据库，只需修改providerName。 写在 中用System.Configuration.ConfigurationManager.AppSettings[“name”]检索值。写在 中用System.Configuration.ConfigurationManager.ConnectionStrings[“name”]检索值。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>AppSettings</tag>
        <tag>ConnectionStrings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项目开发]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在一个项目发开中经常会将通用的方法单独封装成一个类库，供其它项目使用，其它项目使用时有两种引用方式。 引用库文件。 直接引用项目文件。 因引用库文件无法随着代码的更新而更改，所以推荐引用项目。 一、新建工程如图： 其中”WPTClient”为开发项目，”WpTLibs”为项目引用类库。 WPTClient代码如下： 12345678910111213141516171819using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string s = &quot;wpt@wpt.com&quot;; Console.Write(WPTLibs.Helper.IsEmail(s)); Console.ReadKey(); &#125; &#125;&#125; WPTLibs的代码如下： 12345678910111213141516using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTLibs&#123; public class Helper &#123; public static bool IsEmail(string s) &#123; return s.Contains(&quot;@&quot;); &#125; &#125;&#125; 二、项目引用“WPTClient” &gt;&gt; “引用” &gt;&gt; “添加引用” &gt;&gt; “项目” &gt;&gt; “解决方案” &gt;&gt; “WPTLibs”]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>多项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法标题]]></title>
    <url>%2F2018%2F10%2F24%2FMarkDown%2F00%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[markdown是一种纯文本格式的标记语言。通过简单的标记语法，可以使普通文本内容具有一定的格式。]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>标题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——流程图]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F10%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[示例：12345678910&apos;&apos;&apos;flowst=&gt;start: 黄忠op=&gt;operation: 重装炮台cond=&gt;condition: penta kill ?e=&gt;end: victoryst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&apos;&apos;&apos; 说明: st 是变量名 start是操作名 黄忠是显示的文本 效果： 可用模块 开始 startst=&gt;start: 开始 结束 ende=&gt;end: 结束 普通操作块 oprationop1=&gt;opration: 第一个操作op2=&gt;opration: 第二个操作 判断块 conditioncond1=&gt;condition: 第一个判断cond2=&gt;condition: 第二个判断 输入输出块 inputoutputio1=&gt;inputoutput: 输入输出块1io2=&gt;inputoutput: 输入输出块2 子任务块sub1=&gt;subroutine: 子任务1sub2=&gt;subroutine: 子任务2 判断与位置控制 判断流程控制con1(yes)-&gt;op1 #yes 的时候回到 op1con1(no)-&gt;e #no 的时候到结束 位置指定cond1(no)-&gt;op2(right)-&gt;op1 #控制 op2 位置置于右边，再由op2 返回 op1#还可以这样 cond1(no,right)cond1(yes)-&gt;e 示例：1234567891011&apos;&apos;&apos;flow st=&gt;start: 黄忠op1=&gt;operation: 警戒地雷cond=&gt;condition: 没有敌人 ？op2=&gt;operation: 追击潜能e=&gt;end: 摧塔 st-&gt;op1-&gt;condcond(no)-&gt;op2(right)-&gt;op1cond(yes)-&gt;e&apos;&apos;&apos; 效果： 流程控制12345678910st-&gt;op1-&gt;e# -&gt; 作为控制流程的操作符，就是指向下一步要操作。# 每一条都算是一条流程# 可以断开写也可以合着写#分开写st-&gt;op1op1-&gt;e#合着写st-&gt;op1-&gt;e 示例一代码1234567&apos;&apos;&apos;st=&gt;start: 黄忠op=&gt;operation: 重装炮台e=&gt;end: victoryst-&gt;op-&gt;e&apos;&apos;&apos; 效果 示例二12345678&apos;&apos;&apos;cond=&gt;condition: 七杀？op=&gt;operation: 继续杀io=&gt;inputoutput: 你已超神！！cond(yes)-&gt;iocond(no)-&gt;op&apos;&apos;&apos; st=>start: 黄忠 op=>operation: 重装炮台 cond=>condition: penta kill ? e=>end: victory st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 黄忠 op1=>operation: 警戒地雷 cond=>condition: 没有敌人 ？ op2=>operation: 追击潜能 e=>end: 摧塔 st->op1->cond cond(no)->op2(right)->op1 cond(yes)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);st=>start: 黄忠 op=>operation: 重装炮台 e=>end: victory st->op->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-2-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-2", options);cond=>condition: 七杀？ op=>operation: 继续杀 io=>inputoutput: 你已超神！！ cond(yes)->io cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-3-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-3", options);]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——代码]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F09%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[单行代码语法将代码包涵于 ` `之间 示例`这是单行代码 Hello World;` 效果这是单行代码 Hello World; 代码块语法代码之间分别用三个反引号包起来，且两边反引号单独占一行 示例\1234function()&#123; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; console.log(&quot;OKKK啊！！&quot;); &#125; \ 效果123function()&#123; console.log(&quot;OKKK啊！！&quot;); &#125;]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——表格]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F08%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[语法 第一行为表头，第二行分隔表头与表内容，第三行及以后为表内容。 列与列之间用‘|’隔开。 第二行指定对齐方式，默认为左对齐，在‘-’右边加上’:’为右对齐 示例12345姓名|技能|排行---|:--:|---:张三|宝刀|老一李四|大刀|老二王五|菜刀|老末 效果 姓名 技能 排行 张三 宝刀 老一 李四 大刀 老二 王五 菜刀 老末]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——列表]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F07%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[无序列表语法无序列表可以用-,+,= 示例：123456- 列表内容-- 列表内容-+ 列表内容++ 列表内容+* 列表内容** 列表内容* 效果： 列表内容- 列表内容- 列表内容+ 列表内容+ 列表内容* 列表内容* 有序列表语法：数字加点 示例：1231. 列表内容12. 列表内容23. 列表内容3 效果： 列表内容1 列表内容2 列表内容3 列表嵌套:语法：上一级和下一级空三个空格 示例：12345678910111213141516- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容- 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 效果： 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——超链接]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F06%E8%B6%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[超链接格式其实与图片的格式差不多 语法[超链接名](超链接地址 &quot;超链接title&quot;)title 可以不加 示例12[谷歌](http://www.google.cn/ &quot;谷歌&quot;)[百度](http://www.baidu.com/ &quot;百度&quot;) 谷歌百度]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>超链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——图片]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F05%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[语法![图片alt](图片地址 &quot;图片title&quot;) 图片alt：图片下面的文字，相当于对文字的解释。屁的我试了没有用，显示的是图片title。图片的titile:图片的标题，当鼠标移动时图片时显示内容。title可以不加。 示例![无处安放](TIM图片20180824154454.jpg &quot;愿安好！！&quot;) 效果 题外话解决如果无法显示图片： 把主体配置文件_config.yml里的 post_asset_folder: false改为true。 在hexo目录下执行npm install hexo-asset-image --save，安装这个插件。]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——分割线]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F04%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[分割线有两个实现方式：1、三个或者三个以上 -三个- --- 三个以上- ---- 2、三个或者三个以上 *三个* *** 三个以上* ****]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>分割线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——引用]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F03%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在引用的文字前加&gt; 就可以了如： 123&gt; 这是引用的内容&gt; &gt; 这是引用的内容&gt; &gt; &gt; &gt; &gt; &gt; &gt; 这是引用的内容 这是引用的内容 这是引用的内容 这是引用的内容]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——字体]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F02%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[加粗将要加粗的文字分别用两个**包起来就可了 快捷键 ctrl + B, 如： **这是加粗的文字**这是加粗的文字 加斜线将要加斜线的文字分别用两个*包起来就可了 快捷键 ctrl + I, 如： *这是倾斜的文字*这是倾斜的文字 既加粗又加斜线这面是既加粗又加斜线的用三个*包括起来 ***这是倾斜加粗的文字***这是倾斜加粗的文字 加删除线加删除线的用两个~~包括起来 ~~这是要加删除线的文字~~这是要加删除线的文字]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——标题]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F01%E6%A0%87%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在想要设置为标题的文字前面加#来表示，一个#代表一级标题，如： # 这是一级标题 这是一级标题 ## 这是二级标题 这是二级标题 ### 这是三级标题 这是三级标题 #### 这是四级标题 这是四级标题 ##### 这是五级标题 这是五级标题 ###### 这是六级标题 这是六级标题]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>标题</tag>
      </tags>
  </entry>
</search>
