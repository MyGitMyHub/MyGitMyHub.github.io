<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MarkDown语法——代码语法高亮]]></title>
    <url>%2F2018%2F11%2F07%2FMarkDown%2F11%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[为了方便文章代码阅读，需要将代码高亮显示。 语法：123&apos;&apos;&apos; 语言&apos;&apos;&apos; 注意 C#语言要使用cs，估计是C#中#是关键字吧 下面整理列出其它语言： 语言 关键字 1C 1c ActionScript actionscript Apache apache AppleScript applescript AsciiDoc asciidoc AspectJ asciidoc AutoHotkey autohotkey AVR Assembler avrasm Axapta axapta Bash bash BrainFuck brainfuck Cap’n Proto capnproto Clojure REPL clojure Clojure clojure CMake cmake CoffeeScript coffeescript C++ cpp C# cs CSS css D d Dart d Delphi delphi Diff diff Django django DOS.bat dos Dust dust Elixir elixir ERB(Embedded Ruby) erb Erlang REPL erlang-repl Erlang erlang FIX fix F# fsharp G-code(ISO 6983) gcode Gherkin gherkin GLSL glsl Go go Gradle gradle Groovy groovy Haml haml Handlebars handlebars Haskell haskell Haxe haxe HTML html HTTP http Ini file ini Java java JavaScript javascript JSON json Lasso lasso Less less Lisp lisp LiveCode livecodeserver LiveScript livescript Lua lua Makefile makefile Markdown markdown Mathematica mathematica Matlab matlab MEL (Maya Embedded Language) mel Mercury mercury Mizar mizar Monkey monkey Nginx nginx Nimrod nimrod Nix nix NSIS nsis Objective C objectivec OCaml ocaml Oxygene oxygene Parser 3 parser3 Perl perl PHP php PowerShell powershell Processing processing Python’s profiler output profile Protocol Buffers protobuf Puppet puppet Python python Q q R r RenderMan RIB rib Roboconf roboconf RenderMan RSL rsl Ruby ruby Oracle Rules Language ruleslanguage Rust rust Scala scala Scheme scheme Scilab scilab SCSS scss Smali smali SmallTalk smalltalk SML sml SQL sql Stata stata STEP Part21(ISO 10303-21) step21 Stylus stylus Swift swift Tcl tcl Tex tex text text/plain Thrift thrift Twig twig TypeScript typescript Vala vala VB.NET vbnet VBScript in HTML vbscript-html VBScript vbscript Verilog verilog VHDL vhdl Vim Script vim Intel x86 Assembly x86asm XL xl XML xml YAML yml]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>代码语法高亮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 静态类]]></title>
    <url>%2F2018%2F11%2F06%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E9%9D%99%E6%80%81%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、定义：静态类基本上与非静态类相同，但存在一个差异：静态类无法实例化。换句话说，无法使用new关键字创建类型的变量。由于不存在任何实例变量，因此可以使用类名本身访问静态类的成员。例如，如果你具有一个静态类，该类名为 UtilityClass，并且具有一个名为 MethodA 的公共方法，如下面的示例所示：12UtilityClass.MethodA(); ` 静态类可以用作只对输入参数进行操作并且不必获取或设置任何内部实例字段的方法集的方便容器。例如，在.Net Framework类库中，静态System.Math类包括执行数学运算，不用在意方法内部的实现，即，通过指定类名和方法名称来应用类的成员，如下面：1234double dub = -3.14;Console.WriteLine(Math.Abs(dub));Console.WriteLine(Math.Floor(dub));Console.WriteLine(Math.Round(dub)); 结果1233.14-4-3 静态类静态类功能： 只包含静态成员 无法进行实例化 会进行密封 不能包含实例构造函数 因此，创建静态类基本上与创建只包含静态成员和私有构造函数相同。私有构造函数可防止类进行实例化。静态类会进行密封，因些不能继承。它不能继承自任何类（除了Object）。静态类不能包含实例构造函数;但是，可以包含静态构造函数。 静态类代码： 1234567public static class MathEx&#123; public static string toString(double value) &#123; return value.ToString(); &#125; &#125; 调用代码：12string mathString = MathEx.toString(3.1415926585);Console.WriteLine(mathString); 调用结果：13.1415926585 静态成员非静态类可以包含静态方法、字段、属性、事件。即使未创建类的任何实例，也可对类调用静态成员。静态成员始终按类名（而不是实例名称）进行访问。静态成员只有一个副本存在（与创建的类的实例数有关）。静态方法和静态属性无法访问其类中的静态属性和方法。 静态方法可以进行重载，但不能进行替代，因为它们属性于类，而不属于类的任何实例。虽然字段不能声明为 static const，不过const字段在其行为方面本质是静态的。使用与静态属性字段相同。无需把对象实例化。 非静态类中的静态类与静态字段，代码：12345678910111213141516public class MathTest&#123; public static string YW = "112"; public string SX = "120"; public const string SL = "250"; public static string SayYW() &#123; return MathTest.YW; &#125; public string SaySX() &#123; return this.SX; &#125;&#125; 调用代码：123456string sayYW = MathTest.SayYW();Console.WriteLine("语文:&#123;0&#125;", sayYW);MathTest mt = new MathTest();string saySX = mt.SaySX();Console.WriteLine("数学：&#123;0&#125;",saySX);Console.WriteLine(MathTest.SL); 调用结果： 123语文:112数学：120250 静态方法与非静态方法的比较一、使用stati修饰的方法是静态方法，否则就是非静态方法。二、差异比较：静态字段： 静态成员属于类所有，非静态成员属于类实例所有。 每创建一个类的实例，都会在内存中为非静态成员新分配存储空间总结：静态成员属于类所有，为各个类的实例所公用，无论类创建了多少实例，类的静态成员在内存中只占一块。静态方法： 静态方法属于类所有，类实例化前即可使用。 非静态方法可以访问类中任何成员，静态方法只能访问类中的静态成员。 静态方法可以使用静态变量，无法使用非静态变量。静态方法在类的实例化前已经确定好存储位置。 总结：静态方法是一种特殊的成员方法，这不属于类的某一个具体实例，而是属于类本身。所以对于静态方法不需要实例化，而是采用 类名.静态方法的格式。 注意： static不能用 this同时使用 静态方法效率比非静态方法效率高，但静态方法不能自动销毁，而实例化方法可以销毁。 静态方法和静态字段创建后使用同一块内在，而实例化的方式会创建多个内存。 C#中的方法有两种：实例方法、静态方法。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>静态类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 密封类]]></title>
    <url>%2F2018%2F11%2F06%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%AF%86%E5%B0%81%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、定义：官方： 通过在类定义前面放置关键字 sealed,可以将类声明为密封类。例如：123public sealed class D&#123;&#125; 密封类不能用作基类。因此，它不能是抽象类，密封类禁止派生。由于密封类从不用作基类，所以有些运行时优化可以略微提高密封类成员的调用速度。 在对基类的虚成员进行重写的派生类上，方法、索引器、属性事件可以将该成员声明为密封成员。在用于以后的派生类时，这将取消成员的虚效果。方法是在类成员声明中将sealed关键字置于override关键字前面。例如：1234public class D:C&#123; public sealed override void DoWork()&#123;&#125;&#125; 自定义： 如果我们不希望自己编写的类被继承; 如果有的类已经没有再被继承的必要这时，我们可以使用sealed修饰符在类中进行声明，以达到该类不能派生其它类的目的，该类就被称为密封类。 密封类不能同时又是抽象类，因为密封类不能用作基类、也不能被继承，而抽象类总是希望被继承的。 描述：密封类可以用来限制扩展性，如果密封了某个类，则其他类不能从该类继承，如果密封了某个成员，则派生类不能重写该成员的实现。默认情况下，不应密封类型和成员。密封可以防止对库的类型和成员进行自定义，但也会影响某些开发人员对可用性的认识。 C# 中使用密封类时，如果类满足如下条件，则应将其密封。 类是静态类。 类包含带有安全信息的继承的受保护成员。 类继承多个虚成员，并且密封每个成员的开发和测试开销明显大于密封整个类。 类是一个要求使用反射进行快速搜索的属性。密封属性可提高反射在检索属性时的性能。 说明： 密封类不能作为基类被继承，但可以继承别的类或接口。 在密封类中不能声明受保护成员或虚成员，因为受保护成员只能从派生类进行访问，而虚成员只能在派生类中重写。 由于密封类的不可继承性，因此密封类不能声明为抽象的，即sealed修饰符不能与abstract修饰符同时使用。 二、示例 密封类例：下面代码声明一个密封类，该密封类中包含一个Int类型的变量和一个返回值类型方法，它们只能通过实例化密封类的对象来访问，而不能被继承。代码如下：1234567891011121314151617public sealed class moneyClass&#123; public int amount = 0 ; public void buyCar() &#123; if(amount &gt; 200000) &#123; Console.WriteLine(&quot;可以买车啦！！&quot;); &#125; else &#123; Console.WriteLine(&quot;好好工作吧！！&quot;); &#125; &#125;&#125; 调用密封类：123moneyClass mc = new moneyClass();mc.amount = 1000000;mc.buyCar(); 结果：1可以买车啦！！ 密封方法并不是每个方法都可以声明为密封方法，密封方法只能用于对基类的虚方法进行实现，并提供具体的实现，所以声明密封方法时，sealed修饰符总是和override修饰符同时使用。 代码：123456789101112131415public class person&#123; public virtual void say() &#123; Console.WriteLine(&quot;我是人类的总称&quot;); &#125;&#125;public sealed class Chinese:person&#123; public sealed override void say() &#123; base.say(); Console.WriteLine(&quot;我是中国人啊！！！&quot;); &#125;&#125; 调用代码：12Chinese cn = new Chinese();cn.say(); 调用结果：12我是人类的总称我是中国人啊！！！ 密封类与密封方法的使用密封类除了不能被继承外，与非密封类的用法大致相同，而密封方法则必须通过重写基类中的虚方法来实现代码：12345678910111213141516public class person&#123; public virtual void say() &#123; Console.WriteLine(&quot;我是人类的总称&quot;); &#125;&#125;public sealed class Chinese:person&#123; public string name = &quot;&quot;; public sealed override void say() &#123; base.say(); Console.WriteLine(&quot;我的名子是：&#123;0&#125;&quot;,name); &#125;&#125; 调用代码：123Chinese cn = new Chinese();cn.name = &quot;二蛋&quot;;cn.say(); 调用结果：12我是人类的总称我的名子是：二蛋 总结：密闭类是修饰为sealed的类，sealed 不能有子类。一般只有系统中的一些基本类声明为sealed。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>密封类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引器]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E7%B4%A2%E5%BC%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[定义官方定义：索引器允许类或结构的实例就像数组一样进索引。无需显式指定类型或实例成员，即可设置或检索索引值。索引器类似于属性，不同之处在于它们的访问器需要使用参数。 码友定义： 索引器允许类或者结构的实例按照与数组的方式进行索引取值，不同的是索引器的访问是带参数的。 索引器是一种特殊的类成员，它能够让对象以类似数组的方式来存取。 下面来定义一泛型类： 123456789101112131415161718public class SampleCollection&lt;W&gt;&#123; /// &lt;summary&gt; /// 声明一个数据用于存储数据元素 /// &lt;/summary&gt; private W[] arr = new W[100]; /// &lt;summary&gt; /// 定义一个索引器允许客户端代码 /// &lt;/summary&gt; /// &lt;param name=&quot;i&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public W this[int i] &#123; get &#123; return arr[i]; &#125; set &#123; arr[i] = value; &#125; &#125;&#125; 主程序调用：123var stringCollection = new SampleCollection&lt;string&gt;();stringCollection[0] = &quot;Hello World!!&quot;;Console.WriteLine(stringCollection[0]); 使用索引器示例一：用数字索引索引器代码：1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 使用数字索引/// &lt;/summary&gt;public class TempRecord&#123; // 定义 private string[] temps = new string[10] &#123; &quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;七&quot;,&quot;八&quot;,&quot;九&quot;,&quot;十&quot; &#125;; public int Lenght &#123; get &#123; return temps.Length; &#125; &#125; public string this[int index] &#123; get &#123; return temps[index]; &#125; set &#123; temps[index] = value; &#125; &#125;&#125; 调用代码：12345678TempRecord tR = new TempRecord();tR[3] = &quot;叁&quot;;tR[5] = &quot;伍&quot;;for(int i = 0; i&lt;10; i++)&#123; Console.WriteLine(&quot;&#123;0&#125; ====》》》&#123;1&#125;&quot;, i, tR[i]);&#125; 结果：1234567891011Hi Index0 ====》》》一1 ====》》》二2 ====》》》三3 ====》》》叁4 ====》》》五5 ====》》》伍6 ====》》》七7 ====》》》八8 ====》》》九9 ====》》》十 示例二： 使用字符串索引索引器代码：1234567891011121314151617181920212223242526272829303132333435public class DayCollection&#123; // 一个周 string[] days = &#123; &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tues&quot;, &quot;Thurs&quot;, &quot;Fri&quot;, &quot;Sat&quot; &#125;; /// &lt;summary&gt; /// 对比输入的日期，如果是目的就输入 /// &lt;/summary&gt; /// &lt;param name=&quot;testDay&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private int GetDay(string testDay) &#123; for(int j = 0; j &lt; days.Length; j++) &#123; if(days[j] == testDay) &#123; return j; &#125; &#125; throw new ArgumentOutOfRangeException(testDay, &quot;搞错了吧！！&quot;); &#125; /// &lt;summary&gt; /// 只读索引器 /// &lt;/summary&gt; /// &lt;param name=&quot;day&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int this[string day] &#123; get &#123; return (GetDay(day)); &#125; &#125;&#125; 调用代码：12DayCollection dc = new DayCollection();Console.WriteLine(dc[&quot;Tues&quot;]); 调用结果：12 示例三：多个索引器参数代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CoordCollectiion&#123; /// &lt;summary&gt; /// 存储数据的容器 /// &lt;/summary&gt; Dictionary&lt;string, int[]&gt; dicArr = new Dictionary&lt;string, int[]&gt;(); /// &lt;summary&gt; /// 存储数据 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int this[string name ,int x, int y] &#123; // 虽然没用，但还是要留用 get &#123; return 1; &#125; set &#123; int[] intVlaue = &#123; x, y &#125;; // listArr.Add(intVlaue); dicArr.Add(name, intVlaue); &#125; &#125; /// &lt;summary&gt; /// 取数据 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int[] this[string name] &#123; get &#123; bool bContain = dicArr.ContainsKey(name); if (bContain) &#123; return dicArr[name]; &#125; throw new Exception(&quot;没找到对应数据!!&quot;); &#125; &#125;&#125; 调用代码： 1234/// 重载索引器CoordCollectiion cc = new CoordCollectiion();int a = cc[&quot;one&quot;, 111, 222];int b = cc[&quot;two&quot;, 222, 333];]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>索引器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppSettings和ConnectionStrings的区别]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2FAppSettings%E5%92%8CConnectionStrings%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[三种配置文件 web.config是web应用程序的配置文件，为web应用程序担相应配置（B/S）。 app.config是桌面端应用程序的配置文件，为桌面应用程序提供相应配置文件。 AppSettings是ASP.Net1.1时期用的。ConnectionStrings是.Net Framework 2.0 新增的 一、 connectionStrings]以下是App.config配置： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5.2&quot; /&gt; &lt;/startup&gt; &lt;connectionStrings&gt; &lt;add name=&quot;ConnStrHello&quot; connectionString=&quot;Data Source=LEIKE;Initial Catalog=SYXT;User ID=sa;Password=sa&quot; providerName=&quot;System.Data.SqlClient&quot; /&gt; &lt;/connectionStrings&gt;&lt;/configuration&gt; 以下是主应用程序调用示例： 123456789101112131415161718using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string cs = ConfigurationManager.ConnectionStrings[&quot;ConnStrHello&quot;].ConnectionString; Console.ReadKey(); &#125; &#125;&#125; 二、 appSettings以下为App.config配置内容： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5.2&quot; /&gt; &lt;/startup&gt; &lt;appSettings&gt; &lt;add key=&quot;mobile&quot; value =&quot;10085&quot;/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 以下为主应用程序调用示例：12345678910111213141516171819using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string sys = ConfigurationManager.AppSettings[&quot;mobile&quot;]; Console.Write(sys); Console.ReadKey(); &#125; &#125;&#125; 三、区别 AppSettings 是在2003中常用的，ConnectionStrins是2005中常用的. 使用ConnectionString的好处： 第一：可将连接字符串加密，使用MS的一个加密工具即可。 第二：可直接邦定的数据源控件，而不必写代码读出来再赋值给控件。 第三：可方便的更换数据库平台，如换为Oracle数据库，只需修改providerName。 写在 中用System.Configuration.ConfigurationManager.AppSettings[“name”]检索值。写在 中用System.Configuration.ConfigurationManager.ConnectionStrings[“name”]检索值。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>AppSettings</tag>
        <tag>ConnectionStrings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项目开发]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在一个项目发开中经常会将通用的方法单独封装成一个类库，供其它项目使用，其它项目使用时有两种引用方式。 引用库文件。 直接引用项目文件。 因引用库文件无法随着代码的更新而更改，所以推荐引用项目。 一、新建工程如图： 其中”WPTClient”为开发项目，”WpTLibs”为项目引用类库。 WPTClient代码如下： 12345678910111213141516171819using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string s = &quot;wpt@wpt.com&quot;; Console.Write(WPTLibs.Helper.IsEmail(s)); Console.ReadKey(); &#125; &#125;&#125; WPTLibs的代码如下： 12345678910111213141516using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTLibs&#123; public class Helper &#123; public static bool IsEmail(string s) &#123; return s.Contains(&quot;@&quot;); &#125; &#125;&#125; 二、项目引用“WPTClient” &gt;&gt; “引用” &gt;&gt; “添加引用” &gt;&gt; “项目” &gt;&gt; “解决方案” &gt;&gt; “WPTLibs”]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>多项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法标题]]></title>
    <url>%2F2018%2F10%2F24%2FMarkDown%2F00%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[markdown是一种纯文本格式的标记语言。通过简单的标记语法，可以使普通文本内容具有一定的格式。]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>标题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——流程图]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F10%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[示例：12345678910&apos;&apos;&apos;flowst=&gt;start: 黄忠op=&gt;operation: 重装炮台cond=&gt;condition: penta kill ?e=&gt;end: victoryst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&apos;&apos;&apos; 说明: st 是变量名 start是操作名 黄忠是显示的文本 效果： 可用模块 开始 startst=&gt;start: 开始 结束 ende=&gt;end: 结束 普通操作块 oprationop1=&gt;opration: 第一个操作op2=&gt;opration: 第二个操作 判断块 conditioncond1=&gt;condition: 第一个判断cond2=&gt;condition: 第二个判断 输入输出块 inputoutputio1=&gt;inputoutput: 输入输出块1io2=&gt;inputoutput: 输入输出块2 子任务块sub1=&gt;subroutine: 子任务1sub2=&gt;subroutine: 子任务2 判断与位置控制 判断流程控制con1(yes)-&gt;op1 #yes 的时候回到 op1con1(no)-&gt;e #no 的时候到结束 位置指定cond1(no)-&gt;op2(right)-&gt;op1 #控制 op2 位置置于右边，再由op2 返回 op1#还可以这样 cond1(no,right)cond1(yes)-&gt;e 示例：1234567891011&apos;&apos;&apos;flow st=&gt;start: 黄忠op1=&gt;operation: 警戒地雷cond=&gt;condition: 没有敌人 ？op2=&gt;operation: 追击潜能e=&gt;end: 摧塔 st-&gt;op1-&gt;condcond(no)-&gt;op2(right)-&gt;op1cond(yes)-&gt;e&apos;&apos;&apos; 效果： 流程控制12345678910st-&gt;op1-&gt;e# -&gt; 作为控制流程的操作符，就是指向下一步要操作。# 每一条都算是一条流程# 可以断开写也可以合着写#分开写st-&gt;op1op1-&gt;e#合着写st-&gt;op1-&gt;e 示例一代码1234567&apos;&apos;&apos;st=&gt;start: 黄忠op=&gt;operation: 重装炮台e=&gt;end: victoryst-&gt;op-&gt;e&apos;&apos;&apos; 效果 示例二12345678&apos;&apos;&apos;cond=&gt;condition: 七杀？op=&gt;operation: 继续杀io=&gt;inputoutput: 你已超神！！cond(yes)-&gt;iocond(no)-&gt;op&apos;&apos;&apos; st=>start: 黄忠 op=>operation: 重装炮台 cond=>condition: penta kill ? e=>end: victory st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 黄忠 op1=>operation: 警戒地雷 cond=>condition: 没有敌人 ？ op2=>operation: 追击潜能 e=>end: 摧塔 st->op1->cond cond(no)->op2(right)->op1 cond(yes)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);st=>start: 黄忠 op=>operation: 重装炮台 e=>end: victory st->op->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-2-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-2", options);cond=>condition: 七杀？ op=>operation: 继续杀 io=>inputoutput: 你已超神！！ cond(yes)->io cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-3-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-3", options);]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——代码]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F09%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[单行代码语法将代码包涵于 ` `之间 示例`这是单行代码 Hello World;` 效果这是单行代码 Hello World; 代码块语法代码之间分别用三个反引号包起来，且两边反引号单独占一行 示例\1234function()&#123; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; console.log(&quot;OKKK啊！！&quot;); &#125; \ 效果123function()&#123; console.log(&quot;OKKK啊！！&quot;); &#125;]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——表格]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F08%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[语法 第一行为表头，第二行分隔表头与表内容，第三行及以后为表内容。 列与列之间用‘|’隔开。 第二行指定对齐方式，默认为左对齐，在‘-’右边加上’:’为右对齐 示例12345姓名|技能|排行---|:--:|---:张三|宝刀|老一李四|大刀|老二王五|菜刀|老末 效果 姓名 技能 排行 张三 宝刀 老一 李四 大刀 老二 王五 菜刀 老末]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——列表]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F07%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[无序列表语法无序列表可以用-,+,= 示例：123456- 列表内容-- 列表内容-+ 列表内容++ 列表内容+* 列表内容** 列表内容* 效果： 列表内容- 列表内容- 列表内容+ 列表内容+ 列表内容* 列表内容* 有序列表语法：数字加点 示例：1231. 列表内容12. 列表内容23. 列表内容3 效果： 列表内容1 列表内容2 列表内容3 列表嵌套:语法：上一级和下一级空三个空格 示例：12345678910111213141516- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容- 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 效果： 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——超链接]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F06%E8%B6%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[超链接格式其实与图片的格式差不多 语法[超链接名](超链接地址 &quot;超链接title&quot;)title 可以不加 示例12[谷歌](http://www.google.cn/ &quot;谷歌&quot;)[百度](http://www.baidu.com/ &quot;百度&quot;) 谷歌百度]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>超链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——图片]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F05%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[语法![图片alt](图片地址 &quot;图片title&quot;) 图片alt：图片下面的文字，相当于对文字的解释。屁的我试了没有用，显示的是图片title。图片的titile:图片的标题，当鼠标移动时图片时显示内容。title可以不加。 示例![无处安放](TIM图片20180824154454.jpg &quot;愿安好！！&quot;) 效果 题外话解决如果无法显示图片： 把主体配置文件_config.yml里的 post_asset_folder: false改为true。 在hexo目录下执行npm install hexo-asset-image --save，安装这个插件。]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——分割线]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F04%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[分割线有两个实现方式：1、三个或者三个以上 -三个- --- 三个以上- ---- 2、三个或者三个以上 *三个* *** 三个以上* ****]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>分割线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——引用]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F03%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在引用的文字前加&gt; 就可以了如： 123&gt; 这是引用的内容&gt; &gt; 这是引用的内容&gt; &gt; &gt; &gt; &gt; &gt; &gt; 这是引用的内容 这是引用的内容 这是引用的内容 这是引用的内容]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——字体]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F02%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[加粗将要加粗的文字分别用两个**包起来就可了 快捷键 ctrl + B, 如： **这是加粗的文字**这是加粗的文字 加斜线将要加斜线的文字分别用两个*包起来就可了 快捷键 ctrl + I, 如： *这是倾斜的文字*这是倾斜的文字 既加粗又加斜线这面是既加粗又加斜线的用三个*包括起来 ***这是倾斜加粗的文字***这是倾斜加粗的文字 加删除线加删除线的用两个~~包括起来 ~~这是要加删除线的文字~~这是要加删除线的文字]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——标题]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F01%E6%A0%87%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在想要设置为标题的文字前面加#来表示，一个#代表一级标题，如： # 这是一级标题 这是一级标题 ## 这是二级标题 这是二级标题 ### 这是三级标题 这是三级标题 #### 这是四级标题 这是四级标题 ##### 这是五级标题 这是五级标题 ###### 这是六级标题 这是六级标题]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>标题</tag>
      </tags>
  </entry>
</search>
