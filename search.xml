<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C# 匿名委托]]></title>
    <url>%2F2019%2F01%2F04%2FRPCShap%2F02%E5%A7%94%E6%89%98%E3%80%81lambda%E3%80%81%E4%BA%8B%E4%BB%B6%2F05%E5%8C%BF%E5%90%8D%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[使用Delegate的时候没必要使用普通的方法，因为有时这个方法只有这个委托会用，并且只用一次，这时候使用匿名委托最合适。匿名方法就是没有名称的方法。定义：1MyDelegate p = delegate(int s)&#123;s = 10 &#125;; 实例一 普通委托求最大值声明一个委托1public delegate bool CompareSome(object obj1,object obj2); 委托实现比较大小方法：123456static bool CompareInt(object obj1,object obj2)&#123; int compare1 = (int)obj1; int compare2 = (int)obj2; return compare1 &lt; compare2;&#125; 调用：123456789static void Main(string[] args)&#123; // 求最大值： CompareSome CI = CompareInt; object[] objArray = &#123; 1, 3, 2, 35, 32 &#125;; object oMax = compareObj(objArray, CI); Console.WriteLine("最大值为:&#123;0&#125;",Convert.ToInt32(oMax)); Console.ReadKey();&#125; 12345678910111213static object compareObj(object[] objArr,CompareSome intCompare)&#123; object objMax = objArr[0]; for (int i = 0; i &lt; objArr.Length; i++) &#123; if (intCompare(objMax, objArr[i])) &#123; objMax = objArr[i]; &#125; &#125; return objMax;&#125; 结果： 1最大值为:35 实例二 匿名委托求最小值声明一个委托1public delegate bool CompareSome(object obj1,object obj2); 调用：123456789101112131415static void Main(string[] args)&#123; // 求最大值： object[] objArray = &#123; 1, 3, 2, 35, 32 &#125;; // 求最小值： CompareSome CM = delegate (object obj1, object obj2) &#123; int compare1 = (int)obj1; int compare2 = (int)obj2; return compare1 &gt; compare2; &#125;; object oMin = compareObj(objArray, CM); Console.WriteLine("最小值为:&#123;0&#125;", Convert.ToInt32(oMin)); Console.ReadKey();&#125; 123456789101112static object compareObj(object[] objArr,CompareSome intCompare)&#123; object objMax = objArr[0]; for (int i = 0; i &lt; objArr.Length; i++) &#123; if (intCompare(objMax, objArr[i])) &#123; objMax = objArr[i]; &#125; &#125; return objMax;&#125; 结果：1最小值为:1]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>匿名委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置泛型委托]]></title>
    <url>%2F2018%2F12%2F29%2FRPCShap%2F02%E5%A7%94%E6%89%98%E3%80%81lambda%E3%80%81%E4%BA%8B%E4%BB%B6%2F04%E5%86%85%E7%BD%AE%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[定义普通委托时主要是定义委托参数与委托返回值,如：1public delegate void say(string info); .Net FrameWork 针对委托参数与返回值类型内置了两大类委托类型：123public delegate void Action&lt;in T&gt;(T obj);public delegate TResult Func&lt;out TResult&gt;(); 介绍泛型Action&lt;T&gt;委托表示引用一个void返回类型的方法。Action&lt;T&gt;委托类存在不同的变体，没有泛型参数的Action类可以调用没有参数的方法。Func&lt;T&gt;的用法和Action&lt;T&gt;用法类似，但是Func&lt;T&gt;表示引用一个带返回类型的方法，Func&lt;T&gt;也存在不同的变体。 下面以实例说明： Action(无返回值)Action(int T)封装一个方法，该方法只有一个参数并且没有返回值1public delegate void Action&lt;int T&gt;(T obj); 实例：1234567891011121314151617static void Main(string[] args)&#123; List&lt;string&gt; names = new List&lt;string&gt;(); names.Add("Jack"); names.Add("Luck"); names.Add("YaYa"); names.Add("Lili"); // names.ForEach(i =&gt; &#123; Console.WriteLine(i); &#125;); // 这种lambda很漂亮 names.ForEach(Print); Console.ReadKey();&#125;static void Print(string name)&#123; Console.WriteLine(name);&#125; 结果：1234JackLuckYaYaLili 说明：可以使用Action&lt;T&gt;委托作为参数传递方法，而无需显示声明自定义委托。封装的方法必须对应于此委托定义的方法签名。意思是，封装的方法必须具有按值传递给它的一个参数，并且不能返回值。 Action(in T1,in T2)封装一个方法,该方法具有两个参数且不返回值。1public delegate void Action&lt;in T1,in T2&gt;(T1 arg1, T2 arg2); 实例：12345678910static void Main(string[] args)&#123; Action&lt;int, int&gt; calcArea2 = delegate (int i, int ii) &#123; int recArea = i * ii; Console.WriteLine("矩形面积2为:&#123;0&#125;", recArea); &#125;; calcArea2(7, 9); Console.ReadKey();&#125; 结果：1矩形面积2为:63 Action(in T1,in T2,int T3)封装一个方法，该方法具有三个参数且不返回值1public delegate void Action&lt;int T1,int T2,int T3&gt;(T1 arg1,T2 arg2, T3 arg3); 实例：12345678910111213static void Main(string[] args)&#123; string[] ordinals = &#123; "first", "second", "third", "fourth", "fifth" &#125;; string[] copiedOrdinals = new string[ordinals.Length]; Action&lt;string[], string[], int&gt; copyOperation2 = delegate (string[] arr1, string[] arr2, int StartIndex) &#123; CopyStrings(arr1, arr2, StartIndex); &#125;; copyOperation2(ordinals, copiedOrdinals, 2); foreach (string item in copiedOrdinals) &#123; Console.WriteLine(string.IsNullOrEmpty(item)?"&lt;Null&gt;" : item); &#125; Console.ReadKey();&#125; 委托实现：1234567891011private static void CopyStrings(string[] source,string[] target,int startPos)&#123; if(source.Length != target.Length) &#123; throw new IndexOutOfRangeException("数据源数组与目标数组长度必须一致"); &#125; for (int ctr = startPos; ctr &lt; source.Length; ctr++) &#123; target[ctr] = string.Copy(source[ctr]); &#125;&#125; 结果：12345&lt;Null&gt;&lt;Null&gt;thirdfourthfifth 1234...此处省略一万行 Action(in T1,in T2,in T3,in T4,in T5,in T6,in T7,in T8,in T9,in T10,in T11,in T12,in T13,in T14,in T15,in T16)封装一个方法，该方法具有 16 个参数并且不返回值。1public delegate void Action&lt;in T1,in T2,in T3,in T4,in T5,in T6,in T7,in T8,in T9,in T10,in T11,in T12,in T13,in T14,in T15,in T16&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16); 说明：可以使用Action&lt;T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16&gt;委托作为参数传递方法，而无需显式声明自定义委托。 封装的方法必须对应于此委托定义的方法签名。 这意味着，封装的方法必须具有 16 个参数是按值传递给它，并且不能返回值。 (在 C# 中，该方法必须返回void。 Func(有返回值)Func(out TResult)封装一个不具有参数但却返回TResult参数指定的类型值的方法。1public delegate TResult Func&lt;out TResult&gt;(); 实例：1234567static void Main(string[] args)&#123; Func&lt;bool&gt; SayHi = SayHello; Console.WriteLine(SayHi()); Console.ReadKey();&#125; 委托实现：123456static bool SayHello()&#123; Console.WriteLine("Hello EveryBody!!"); return true;&#125; 结果：12Hello EveryBody!!True Func(int T,out TResult)封装一个具有一个参数并且返回TResult参数指定的类型值的方法1public delegate TResult Func&lt;int T,out TResult&gt;(T arg); 实例：1234567static void Main(string[] args)&#123; Func&lt;string, string&gt; cm2 = UpperCaseString; string name2 = "Ptw"; Console.WriteLine(cm2(name2)); Console.ReadKey();&#125; 委托实现：1234private static string UpperCaseString(string inputString)&#123; return inputString.ToUpper();&#125; 结果：1PTW Func(int T1,Int T2, out TResult)封装一个具有两个参数并返回TResult参数指定的类型值的方法。1public delegate TResult Fun&lt;int T1,Int T2, out TResult&gt;(T1 arg1,T2 arg2); 实例：12345678910static void Main(string[] args)&#123; Func&lt;string, int,string[]&gt; Em2 = ExtractWords; string titleWords = "how are you "; foreach (string item in Em2(titleWords,5)) &#123; Console.WriteLine(item); &#125; Console.ReadKey();&#125; 委托实现：12345678private static string[] ExtractWords(string phrase, int limit)&#123; char[] delimiters = new char[] &#123; ' ' &#125;; if (limit &gt; 0) return phrase.Split(delimiters, limit); else return phrase.Split(delimiters);&#125; 结果：123howareyou 1234...此处省略一万行 Func(in T1,in T2,in T3,in T4,in T5,in T6,in T7,in T8,in T9,in T10,in T11,in T12,in T13,in T14,in T15,in T16,out TResult)封装一个方法，该方法具有16个参数，并返回 TResult参数所指定的类型的值。1public delegate TResult Func&lt;in T1,in T2,in T3,in T4,in T5,in T6,in T7,in T8,in T9,in T10,in T11,in T12,in T13,in T14,in T15,in T16,out TResult&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16); 说明：可以使用此委托来表示以作为参数传递而无需显示声明自定义委托方法。封装的方法必须对应于此委托定义的方法签名。这意味着，封装的方法必须有16个参数，其中每个按值传递给它，并且必须返回一个值。Lambda表达式的基础类型是一个泛型Func委托。这样，可以将Lambda表达式作为参数传递而无需显式将其分配给委托。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Action&lt;T&gt;</tag>
        <tag>Func&lt;T&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 泛型委托]]></title>
    <url>%2F2018%2F12%2F28%2FRPCShap%2F02%E5%A7%94%E6%89%98%E3%80%81lambda%E3%80%81%E4%BA%8B%E4%BB%B6%2F03%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[前面总结果了委托类型的使用，但是存在装箱、拆箱的操作不太方便平时使用，下面学习下泛型委托。普通委托：1public delegate int 委托名&#123;object obj1,object obj2&#125;; 委托定义有以下特点： 访问修饰符 delegate关键字 返回值和参数委托是一种类型，与之对应的方法和它具有相同的签名，即相同的参数个数，相同的参数类型和相同的返回值类型。泛型委托：1public delegate T 委托名&lt;T&gt;(T a,T b) 与普通委托不同是把object类型换成了任意类型T下面重写上篇求最大值的事例： 一、新建一个委托类12345678910111213141516class FXWT&#123; public static T GetFXWTMax&lt;T&gt;(T[] obj, FXWTMax&lt;T&gt; func) &#123; T tMax = obj[0]; for (int i = 0; i &lt; obj.Length; i++) &#123; if (!func(tMax,obj[i])) &#123; tMax = obj[i]; &#125; &#125; return tMax; &#125;&#125;public delegate bool FXWTMax&lt;T&gt;(T obj1,T obj2); 一、比较Int类型数据1. 声明一个Int数组 1int[] FXIntArray = &#123; 1, 32, 5, 3, 5, 2, 5, 545, 3, 33 &#125;; 2. 实现比较方法1234public static bool GetIntMaxFX(int tem1,int tem2)&#123; return tem1 &gt; tem2;&#125; 3. 调用委托方法求Int数据的最大值12object floatMax = GetMaxClass.GetObjectMax(floatArray, GetFloatMax);Console.WriteLine("Float类型的最大值为:&#123;0&#125;",floatMax); 4. 结果1Int类型的最大值为：545 二、比较Float类型数据1. 声明一个Float数组 1float[] FXFloatArray = &#123; 2.26f, 23.23f, 424.2332f,32.233f,32f &#125;; 2. 实现Float数据对比方法 1234public static bool GetFloatFX(float tem1,float tem2)&#123; return tem1 &gt; tem2;&#125; 里其实可以与Int类型数据比较用同一个比较方法 3. 调用委托方法求Float数据的最大值。12float floatMaxFX = FXWT.GetFXWTMax&lt;float&gt;(FXFloatArray, GetFloatFX);Console.WriteLine("Float类型的最大值为：&#123;0&#125;", floatMaxFX); 这里其实也可以简写如下：1float floatMaxFX = FXWT.GetFXWTMax(FXFloatArray, GetFloatFX); 4. 结果：1Float类型的最大值为：424.2332 三、复杂类型比较1. 声明一个Person类 123456789101112131415161718192021222324252627282930313233343536class Person&#123; private string name; private int age; public Person(string name,int age) &#123; this.Name = name; this.Age = age; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public int Age &#123; get &#123; return age; &#125; set &#123; age = value; &#125; &#125;&#125; 2. 实例化一些人类123456Person[] FXPersonArray =&#123; new Person("张三",17), new Person("李四",12), new Person("王五",20)&#125;; 3. 实现Person类的比较方法1234public static bool GetPersonMaxFX(Person tem1,Person tem2)&#123; return tem1.Age &gt; tem2.Age;&#125; 4. 调用委托方法求年龄最大的人类12Person personMaxFX = FXWT.GetFXWTMax&lt;Person&gt;(FXPersonArray, GetPersonMaxFX);Console.WriteLine("年龄最大的人是:&#123;0&#125;,年龄为:&#123;1&#125;", personMaxFX.Name, personMaxFX.Age); 5. 结果1年龄最大的人是:王五,年龄为:20]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>泛型委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 委托实例]]></title>
    <url>%2F2018%2F12%2F27%2FRPCShap%2F02%E5%A7%94%E6%89%98%E3%80%81lambda%E3%80%81%E4%BA%8B%E4%BB%B6%2F02%E5%A7%94%E6%89%98%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[上面总结下委托的基本用法，下面写个小实例; 求最大值：一、 新建一个委托类12345678910111213141516171819202122// Int 委托public delegate bool getMax(object obj1, object obj2);class GetMaxClass&#123; /// &lt;summary&gt; /// 取最大值方法 /// &lt;/summary&gt; /// &lt;param name="obj"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static object GetObjectMax(object[] obj,getMax maxFunc) &#123; Object objMax = obj[0]; for (int i = 0; i &lt; obj.Length; i++) &#123; if (!maxFunc(objMax,obj[i])) &#123; objMax = obj[i]; &#125; &#125; return objMax; &#125;&#125; 说明：因不确实要比较的obj1与obj2是什么数据类型，所以此处声明为object,GetObjectMax方法中obj参数是数据源数组，maxFun是比较方法，在外部实现。 一、比较Int类型数据1. 声明一个数据，此处声明一个Int数组;1object[] intArray = &#123; 1, 3, 343, 434, 23, 53, 43, 3 &#125;; 因 Int[]无法直接转换到object[]所以此处声明为：object[];所以此处存在一个装箱的过程; 2. 实现比较方法123456public static bool GetIntMax(object tem1,object tem2)&#123; int compare1 = (int)tem1;// 拆箱要装箱一致 int compare2 = (int)tem2; return compare1 &gt; compare2;&#125; 比较大小前要先拆箱，拆箱时数据类型要与装箱时保持一致。 3. 调用委托方法求最大值123getMax gm = GetIntMax;object inMax = GetMaxClass.GetObjectMax(intArray,gm);Console.WriteLine("Int类型的最大值为：&#123;0&#125;", inMax); 也可以简写成：12object inMax = GetMaxClass.GetObjectMax(intArray, new getMax(GetIntMax));Console.WriteLine("Int类型的最大值为：&#123;0&#125;", inMax); 4. 结果1Int类型的最大值为：434 同样利用相同的委托开比较Float数据类型 二、比较Float数据类型1. 声明一个Float数组; 1object[] floatArray = &#123; 2.12f, 32.23f, 332.23f, 2242.32f &#125;; 2. 实现Float数据比较方法123456public static bool GetFloatMax(object tem1,object tem2)&#123; float compare1 = (float)tem1; float compare2 = (float)tem2; return compare1 &gt; compare2;&#125; 3. 调用委托方法求Float类型最大值12object floatMax = GetMaxClass.GetObjectMax(floatArray, GetFloatMax);Console.WriteLine("Float类型的最大值为:&#123;0&#125;",floatMax); 4. 结果1Float类型的最大值为:2242.32 三、类对象比较1. 声明一个Person类123456789101112131415161718192021222324252627282930313233343536class Person&#123; private string name; private int age; public Person(string name,int age) &#123; this.Name = name; this.Age = age; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public int Age &#123; get &#123; return age; &#125; set &#123; age = value; &#125; &#125;&#125; 2. 实现Person数据比较方法，这里按年龄(Age)比较123456public static bool GetPersonMax(object tem1, object tem2)&#123; Person compare1 = (Person)tem1; Person compare2 = (Person)tem2; return compare1.Age &gt; compare2.Age;&#125; 3. 调用委托方法求Person类的最大值12Person personMax = (Person)GetMaxClass.GetObjectMax(personArray, GetPersonMax);Console.WriteLine("Peoson类中年龄最大的名子是&#123;0&#125;,年龄为:&#123;1&#125;",personMax.Name,personMax.Age); 4. 结果1Peoson类中年龄最大的名子是张飞,年龄为:42 二、泛型委托12345678910111213141516class FXWT&#123; public static T GetFXWTMax&lt;T&gt;(T[] obj, FXWTMax&lt;T&gt; func) &#123; T tMax = obj[0]; for (int i = 0; i &lt; obj.Length; i++) &#123; if (!func(tMax,obj[i])) &#123; tMax = obj[i]; &#125; &#125; return tMax; &#125;&#125;public delegate bool FXWTMax&lt;T&gt;(T obj1,T obj2); 声明一个类型为T返回值为bool类型的泛型委托]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>委托实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 委托]]></title>
    <url>%2F2018%2F12%2F26%2FRPCShap%2F02%E5%A7%94%E6%89%98%E3%80%81lambda%E3%80%81%E4%BA%8B%E4%BB%B6%2F01%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[定义： 委托是一种数据类型，可能声明委托类型变量。 委托是一种可以指向方法的数据类型委托是一种指向方法的数据类型。 声明方式delegate 返回值类型 委托类型名(参数)比如：1delegate void sayChinese(string info;) 注意：这里的除了前的delegate,剩下部分和声明一个函数是一样的，但是sayChinese并不是函数名，而是委托类型名。 示例：委托定义：12345// 不带参数，无返回值public delegate void sayHello();// 带有参数,无返回值public delegate void sayThing(string something);public delegate int claculate(int Int1); 委托调用：123456789// 标准写法sayHello sh = new sayHello(sayHi);sh();// 简写sayHello sh1 = sayHi;sh1();sayThing st = sayThing;st("WPT"); 委托实现方法123456789public static void sayHi()&#123; Console.WriteLine("Good Moning sir!");&#125;public static void sayThing(string some)&#123; Console.WriteLine("Hi:&#123;0&#125;", some);&#125; sayHello sh = new sayHello(sayHi);也可以简写成：sayHello sh1 = sayHi; 不要把MyDel d1 = new MyDel(M1);MyDel d1 = M1;声明成:MyDel d1 = new MyDel(M1());MyDel d1 = M1();因为加上括号就代表调用方法了 委托是引用类型，可以为null，如果委托变量为null，那么如果调用的话，就会抛出NullReferenceException]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# out和ref之间的区别]]></title>
    <url>%2F2018%2F12%2F25%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2Fref%E5%92%8Cout%2F</url>
    <content type="text"><![CDATA[C#中函数返回值只有一个，当需要多个返回值时就要用到ref和out. 相同点：两者都是按地址传递，使用后都将改变原来参数的数值。 不同点：ref传递时需先赋值，out不需要。 什么时候用ref当参数做为引用类型，要求返回时用ref，毕竟在进入函数前已经赋值了。 什么时候用out当函数有多个返回值时，就是单纯的返回值，传入时对函数没有影响。 ref关键字代码：12345678int bRef = 0;refTest(ref bRef);Console.WriteLine("bRef的值为:&#123;0&#125;",bRef);static void refTest(ref int bRef)&#123; bRef = 1;&#125; 结果：1bRef的值为:1 out关键字12345678int aOut;outTest(out aOut);Console.WriteLine("aOut的值为：&#123;0&#125;",aOut);static void outTest(out int aOut)&#123; aOut = 1;&#125; 结果：1aOut的值为：1]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>out与ref</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 字符串的暂存池]]></title>
    <url>%2F2018%2F12%2F12%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%9A%82%E5%AD%98%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[概述在.Net中字条串属于基本数据类型，也是基本数据类型中唯一的引用类型。字符串可以声明常量，却放在堆中。 不可改变对象在.Net中String是不可改变的对象，一旦创建了一个String对象并为它赋值，它就不可能再改变。 代码：1234string name = "huang";Console.WriteLine(name);name += "zhong";Console.WriteLine(name); 结果：12huanghuangzhong 说明： 看似name的值从”huang”改为”huangzhong”,其实是因为字符串属于引用类型，在开始时创建了一个内存用于存放”huang”,在后面又创建了另一个内存空间用于存放”huangzhong”,name指向了新的内存地址。这时内存堆中已存在两个对象，我们引用了一个”huangzhong”,但另一个”huang”依然存在。 暂存池机制 驻留池由CLR来维护，其中的所有字符串对象的值都不相同驻留池中的所有字符串都不一样，以此来保证相同字符串的引用地址是相同的。 只有编译阶段的文本字符常会被自动添加到驻留池，运行时期动态创建的字符串不会被加入到驻留池中。【重要】如：string s1 = “hello” 加到池子里。string s2 = s1.substring(1,2);这是运行时创建的，所以不加入池子里。 可以使用静态方法String.Intern(string)把动态创建的字符串加入到驻留池中。 代码：12345678String s1 = "MyTest";String s2 = new StringBuilder().Append("My").Append("Test").ToString(); String s3 = String.Intern(s2); Console.WriteLine("s1 == '&#123;0&#125;'", s1);Console.WriteLine("s2 == '&#123;0&#125;'", s2);Console.WriteLine("s3 == '&#123;0&#125;'", s3);Console.WriteLine("Is s2 the same reference as s1?: &#123;0&#125;", (Object)s2==(Object)s1); Console.WriteLine("Is s3 the same reference as s1?: &#123;0&#125;", (Object)s3==(Object)s1); 结果：12345s1 == 'MyTest's2 == 'MyTest's3 == 'MyTest'Is s2 the same reference as s1?: FalseIs s3 the same reference as s1?: True]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>暂存池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 关于相等(二)]]></title>
    <url>%2F2018%2F12%2F11%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%85%B3%E4%BA%8E%E7%9B%B8%E7%AD%89(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[上篇中总结了四种判等函数，比较好理解是Oject.RerenceEquals,它只是判定对象是否是相同实例。但对于==和Equals还是比较模糊，所以二次总结一下。 ==与Equals比较一、值类型的比较对于值类型来说，两者比较都是同种类型下的”内容”是否相同，此时两者的作用相同。示例:12345int a = 34;int b = 34;Console.WriteLine("a==b:&#123;0&#125;", a == b);Console.WriteLine("a.Equals(b):&#123;0&#125;", a.Equals(b)); 结果：12a==b:Truea.Equals(b):True 引用类型的比较对于引用类型来说，等号(==)比较的是两个变量的“引用”是否一样，即引用的地址是否相同。而对于equals来说仍然是变量的“内容”是否一样。 字符串的比较1、实例123456// 引用类型// 字符串string str1 = "WPT";string str2 = "WPT";Console.WriteLine("str1 == str2:&#123;0&#125;", str1 == str2);Console.WriteLine("str1.Equals(str2):&#123;0&#125;",str1.Equals(str2)); 结果：12str1 == str2:Truestr1.Equals(str2):True 说明：string 是微软封装的一个字符类，在内部他已经对==操作符进行了重写。重写后他比较的则是两上变量的内容是否相同，重写后==操作符内部调用的即是Equals方法，所以输出的是true 2、自定义的其它引用类型实例1234567891011121314151617181920212223public class Car&#123; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public Car(string value) &#123; this.name = value; &#125; &#125; 调用: 12345Car car1 = new Car("大奔");Car car2 = new Car("大奔");Console.WriteLine("car1 == car2:&#123;0&#125;",car1 == car2);Console.WriteLine("car1.Equals(car2):&#123;0&#125;",car1.Equals(car2)); 结果12car1 == car2:Falsecar1.Equals(car2):False 对于 car1==car2 比较的结果是false，这点是毫无疑问的，因为他俩是两个不同的变量，所以引用的地址也是不同的。但是对于car1.Equals(car2) 返回false，可能有人会产生疑问，car1 和car2的内容是相同的啊，为什么他俩的比较结果却是为false呢？。原因就在于在Equals是Object中的一个虚方法，而Car类中没有对她进行重写，因此此时调用的仍是父类中的Equals方法。但是父类是无法知道你都有哪些成员字段的，因此返回的是false。要想让他能够比较两个变量的内容是否相同，那就应该重写Equals方法.重写Equals:123456789101112131415161718192021222324252627public class Car&#123; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public Car(string value) &#123; this.name = value; &#125; public override bool Equals(object obj) &#123; Car car = (Car)obj; return (this.Name == car.name); &#125;&#125; 结果12car1 == car2:Falsecar1.Equals(car2):True 总结：Equals比较的永远是变量的内容是否相同，而==比较的则是引用地址是否相同(没有重写Equals和==)。string类型是个特例，因为他的内部对这两个都进行了重写。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>关于相等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 关于相等(一)]]></title>
    <url>%2F2018%2F12%2F10%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%85%B3%E4%BA%8E%E7%9B%B8%E7%AD%89(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[.Net提供了四种判等函数 ReferenceEquals。 静态Equals。 具体类型的Equals “==”操作符 一、Object.ReferenceEquals定义：12345678910111213141516//// 摘要:// 确定指定的 System.Object 实例是否是相同的实例。//// 参数:// objA:// 要比较的第一个对象。//// objB:// 要比较的第二个对象。//// 返回结果:// 如果 objA 是与 objB 相同的实例，或如果两者均为 null，则为 true；否则，为 false。[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)][TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]public static bool ReferenceEquals(Object objA, Object objB); 解释：这个函数就是判断两个引用类型是否指向同一个地址。有此说明后，就确定了它的使用范围，即只能对于引用类型操作。那么对于任何值类型数据操作，即使是与自身的判别，都会返回false。这主要因为任何在调用此函数的时候，值类型数据要进行装箱操作。 实例引用类型1234567string s1 = "WPT";string s2 = s1;string s3 = new string(new char[] &#123; 'W', 'P', 'T' &#125;);Console.WriteLine("s1与s2是同一个对象:&#123;0&#125;", object.ReferenceEquals(s1, s2));Console.WriteLine("s1与s3是同一个对象:&#123;0&#125;",object.ReferenceEquals(s1,s3));Console.WriteLine("s1自身比较：&#123;0&#125;", object.ReferenceEquals(s1, s1)); 结果：123s1与s2是同一个对象:Trues1与s3是同一个对象:Falses1自身比较：True 值类型 12345int iTest1 = 110;int iTest2 = iTest1;Console.WriteLine("iTest1自身比较&#123;0&#125;", object.ReferenceEquals(iTest1, iTest1));Console.WriteLine("iTest1与iTest2比较&#123;0&#125;", object.ReferenceEquals(iTest1, iTest2)); 结果：12iTest1自身比较FalseiTest1与iTest2比较False 二、Object.Equals定义123456789101112131415//// 摘要:// 确定指定的对象实例是否被视为相等// 参数:// objA:// 要比较的第一个对象。//// objB:// 要比较的第二个对象。为相等。////// 返回结果:// 如果认为对象相等，则为 true；否则为 false。如果 objA 和 objB 都为 null，则方法返回 true。[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]public static bool Equals(Object objA, Object objB); 参考其它博文，其形式如下： 1234567891011public static bool Equals(object left,object right)&#123; // if(left == right) &#123; return true; &#125; if ((left == null) || right == null) return false; return left.Equals(right);&#125; 实例123456789101112string s1 = "WPT";string s2 = s1;string s3 = new string(new char[] &#123; 'W', 'P', 'T' &#125;);int iTest1 = 110;int iTest2 = iTest1;Console.WriteLine("s1与s2相等：&#123;0&#125;", object.Equals(s1,s1));Console.WriteLine("s1与s3相等：&#123;0&#125;",object.Equals(s1,s3));Console.WriteLine("iTest1自身比较&#123;0&#125;", object.Equals(iTest1, iTest1));Console.WriteLine("iTest1与iTest2比较&#123;0&#125;", object.Equals(iTest1, iTest1)); 结果： 12345s1与s2相等：Trues1与s3相等：TrueiTest1自身比较TrueiTest1与iTest2比较True 三、具体类型的Equals定义123456789101112//// 摘要:// 确定指定的对象是否等于当前对象。//// 参数:// obj:// 要与当前对象进行比较的对象。//// 返回结果:// 如果指定的对象等于当前对象，则为 true；否则为 false。[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]public virtual bool Equals(Object obj); 实例12345678910111213141516171819202122232425262728293031323334353637383940public class HeroClass&#123; private int grade; public int Grade &#123; get &#123; return grade; &#125; set &#123; grade = value; &#125; &#125; public override bool Equals(object right) &#123; // 是否为null if (right == null) &#123; return false; &#125; // 对象地址 if (object.ReferenceEquals(this, right)) &#123; return true; &#125; // 对象类型 if (this.GetType() != right.GetType()) &#123; return false; &#125; // 类型转换 HeroClass rightASKeyData = right as HeroClass; // 成员变量 return this.grade == rightASKeyData.grade; &#125;&#125; 调用：1234567891011HeroClass hz = new HeroClass();hz.Grade = 4;HeroClass ys = hz;HeroClass zy = new HeroClass();Console.WriteLine("hz与ys:&#123;0&#125;", ys.Equals(hz));Console.WriteLine("hz与zy:&#123;0&#125;", zy.Equals(hz));ys.Grade = 5;Console.WriteLine("hz与ys:&#123;0&#125;", ys.Equals(hz)); 结果：1234hz与ys:Truehz与zy:Falsehz与ys:True 四、”==”操作符定义1234567891011121314151617181920212223242526public struct HeroStruct&#123; private int grade; public int Grade &#123; get &#123; return grade; &#125; set &#123; grade = value; &#125; &#125; public static bool operator ==(HeroStruct left,HeroStruct right) &#123; return left.grade == right.grade; &#125; public static bool operator !=(HeroStruct left,HeroStruct right) &#123; return left.grade != right.grade; &#125;&#125; 调用：12345678HeroStruct lb = new HeroStruct();lb.Grade = 4;HeroStruct zf = lb;Console.WriteLine("重载运算符判等lb与zf:&#123;0&#125;",lb == zf);zf.Grade = 5;Console.WriteLine("重载运算符判等lb与zf:&#123;0&#125;", lb == zf); 结果:12重载运算符判等lb与zf:True重载运算符判等lb与zf:False 说明由于==操作符与!=操作要同步定义，所以在定义==重载函数时，也要定义!=重载函数。这也是.Net在判等操作保持一致性。这种重载运算的方法不适合引用类型。判断两个引用不要用==,而要用某个对象的Equals函数。 一张表总结 判等函数 操作结果取决于 适用范围 建议 Object.ReferenceEquals 两参数是否同一个实例 引用类型 不能判断值类型 Object.Equals 参数实例化后比较 无限制 考虑装箱操作对值类型数据产生的影响 类型的Equal 类型重载函数 无限制 考虑装箱操作对值类型数据产生的影响 类型的==重载 类型重载函数 无限制 不要在引用类型中重载此运算符]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>关于相等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 拆箱与装箱]]></title>
    <url>%2F2018%2F12%2F07%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[一、拆箱与装箱准备知识C#中有两种类型：值类型和引用类型 名称 表示类型 存储内容 存储位置 值类型 基本类型 值 堆栈 引用类型 类,数组,接口,委托 值的引用 托管堆 值类型：值类型在栈中分配内存,在声明时初始化才能使用,不用为null。值类型超出作用范围系统自动释放内存。主要由两类组成,结构,枚举(enum), 整形(Sbyte、Byte、Char、Short、Ushort、Int、Uint、Long、Ulong) 浮点型(Float、Double) decimal bool 用户自定义的结构(struct)引用类型：引用类型在堆中分配内存，初始化时默认为null.引用类型是通过垃圾回收机制进行回收。包括类、接口、委托、数组以及内置引用类型object与string. 概念由于C#中所有的数据类型都是由基类System.Object继承而来的,所以值类型和引用类型的值可以通过显式（或隐式）操作相互转换,而这转换过程也就是装箱(boxing)和拆箱(unboxing)过程。 装箱：值类型到objet类型或到此值类型所实现的任何接口类型的隐式转换。对值类型装箱会在堆中分配一个对象实例，并将该值复制到新的对象中。拆箱：object类型到值类型或接口类型到实现该接口类型的显示转换。 操作步骤装箱：对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。 新分配托管化堆内存(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex); 将值类型的实例字段拷贝到新分配的内存中。 返回托管堆中新分配对象的地址。这个地块就是一个指向对象的引用。拆箱：检查对象实例，确保它是给定值类型的一个装箱值，将该值从实例复制到值类型变量中。 注意：装箱时，生成的是全新的引用对象，这会有时间损耗，也就是造成效率降低。实例如下：123var iInt = 123;object oObject = iInt; // 装箱 int ii = (int)oObject; // 拆箱 以上代码装箱时为Int类型，拆箱时同为Int类型所以没有错误。 123decimal iDecimal = 123;object o2 = iDecimal;int iii = (int)o2; // 会有问题， 这里因为装箱时为Decimal类型，而拆箱时却为Int类型，所以会报错。如图： 出于性能方面的考虑应避免使用装箱、过程。方法： 通过重载函数 通过泛型]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>拆箱与装箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# CTS、CLS和CLR]]></title>
    <url>%2F2018%2F12%2F05%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2FCTS%E3%80%81CLS%E5%92%8CCLR%2F</url>
    <content type="text"><![CDATA[平时的学习中对CLR熟悉些，因为CLR是.NET Framework的核心，今天梳理一下CLR、CTS和CLS之间的关系。其实CTS和CLS是CLR的核心。任何编程语言，如果想要在.NET CLR上执行，就必需提供一个编译器，将此语言的程序编译成.NET CLR所认识的metadata以及IL，符合CTS的规定。并非所有的语言都能和C#一样符合CTS的规范，毕竟许多语言出现在先，CTS出现在后，所以有一引些旧的语言未能符合CTS的规定。这类的语言在.NET中有三种方式来符合CTS规范： 改变语言本身以符合CTS规定。 扩充语言本身以接近CTS规定，但仍旧保留不相容于CTS的语法。如此一来，程序中符合CTS规定的以CTS方式编译，不符合CTS规定的则以传统的方式编译成native code。 语言本身尽量维持不变，一切都是通过超强的编译器设计来达成和CTS的相容。 概念1. CTS通用类型系统(Common Type System) CTS不但实现了COM的变量兼容类型，而且还定义了通过用户自定义类型的方式来进行扩展。任何以.NET平台作为目标的语言必须建立它的数据类型与CTS的类型间的映射。所有.NET语言共享这一类型系统，实现它们这间无缝的互操作。该方案还提供了语言之间的继承性。 2. CLS通用语言规范(Common Language Specification) 编程语言的区别不仅仅在于类型。例如，一些语言支持持多继承性，一些语言支持无符号数据类型，一些语言支持运算符合符重载。因此.NET通过定义公共语言规范(CLS),限制了由这些不同引发的互操作性的问题。CLS制定了一种以.NET平台为目标的语言所必须支持的最小特征，以及该语言与其 他.NET语言之间实现互操作性所需要的完备特征。 3. CLR公共语言运行库(Common Language Runtime) 简单地说，CLR是CTS的实现，也就是说，CLR是应用程序的执行引擎和功能齐全的类库，该类库严格按照CTS规范实现。作为程序执行引擎，CLR负责安全地载入和运行用户程序代码，包括对不用对象的垃圾回收和安全检查。在CLR监控之下运行的代码，称为托管代码(managed code)。 白话理解 .Net平台下不只有C#语言，还有VB.Net、F#等语言。IL是程序最终编译的可以执行的二进制代码(托管代码),不同的语言最终编译成标准的IL(中间语言,MSIL):这样C#可以调用VB.Net写的程序集(Assembly,dll、exe)。在平台下：不同语言之间可以互联互通、互相调用。 不同语言中的数据类型各不相同，比如整数类型在VB.Net中是Interger、C#中是int。.Net平台规定了通用数据类型（CTS,Common Type System）,各个语言编译器把自己语言的类型翻译成CTS中的类型。int是C#中的类型，Int32是CTS中的类型;int是C#的关键字，Int32不是。 不同语言的语法不一样，.Net平台规定了通用语言规范（CLS,Common Lauguage Specification）比如定义一个类A继承自B的C#语法是: 1class A:B&#123;&#125; VB.Net的语法是: 1Class A Inherits B IL 代码由公共语言运行时(CLR，Common language Runtime) 驱动运行,CLR提供了垃圾回收（GC，Garbage Collection,没有任何引用的对象可以被自动回收）、JIT(即时编译器)； 值类型是放在“栈内存”中，引用类型放在“堆内存”，栈内存会方法结束后自动释放,”堆内存”则需要GC来回收。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>CTS、CLS和CLR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 值类型与引用类型]]></title>
    <url>%2F2018%2F12%2F03%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本概念C#中，变量是值还是引用取决于数据类型。 C#的预定义类型并没有内置于语言中，而是内置于.NET FrameWork中。.NET使用通用的数据类型系统（CTS)定义了可以在中间语言（IL）中使用的预定义数据类型，所有面向.NET的语言都最终被编辑为IL，即编译为基于CTS类型的代码， 引用类型：引用类型派生自System.Object. 数组(派生于System.Array) 用户自定义的类型 类:class(派生于System.Object); 接口:interface(接口); 委托：delegate(派生于System.Delegate)。 object(System.Object的别名); 字符串：string(System.String的别名) 值类型:值类型均派生自System.valueType(ValueType其实也是继承自Object，不过是特立独行的一个分支) 结构体：struct(直接派生于ValueType); 数据类型: 整形：short(System.Int16), int(System.Int32),long(System.Int64),byte(System.Byte),sbyte(System.SByte),ushort(System.UInt16),uint(System.UInt32),ulong(System.UInt64),char(System.Char); 浮点型：float(System.Single),double(System.Double); 用于财务计算的高精度decimal型：decimal(System.Decimal). bool型bool(System.Boolean的别名)； 用户自定义的结构本（派生于System.ValueType）。 枚举：enum(派生于System.Enum); 可空类型 (派生于System.Nullable泛型结构体，T?实际上是System.Nullable的别名) 值类型实例通常分配在堆栈上，并且不包含任何指向实例数据的指针，因为变量本身就可包含了其实例数据。 引用类型变量的赋值只复制对对象的引用：引用类型的引用地址在堆栈上，值在堆上。值类型变量赋值会拷贝一个副本：值类型在栈内存：值类型一定是sealed; 值类型与引用类型的区别 值类型的数据在内存的栈中，引用类型的数据存储在内存的堆中，而栈(内存单元)只存放堆中对象的地址。 值类型存取速度快，引用类型存取速度慢。 值类型表示实际数据，引用类型表示指存储在内存堆中的数据的指针或引用。 值类型继承自System.ValueType,引用精英继承自System.object. 栈的内存分配是自动释放，而堆在.NET中会有GC来释放。 值类型的变量直接存放实际数据，而引用类型存放的则是数据的地址，即对象的引用。 值类型变量直接把变量的值保存在堆栈中，引用类型的变量把实际数据的地址保存在堆栈中，实际数据保存在堆中。 注意：堆和堆栈是两个不同的概念，在内存中的存储位置也不相同，堆一般用于存储可变长度的数据，如字符串类型；而堆栈则用于存储固定长度的数据，如整型类型的数据int(每个int变量占用四个字节)。由数据存储的位置可以得知，当把一个值变量赋给另一个变量时，会在堆栈中保存丙个完全不相同的值;而把一个引用变量赋给另一个引用变量，则会在堆栈中保存对同一个堆位置的两个引用。 空说无用下面来个例子 123456789101112131415struct HeroStruct&#123; public string name; public string weapon; public string sex;&#125;class HeroClass&#123; public string name; public string weapon; public string sex;&#125; 调用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152HeroStruct LBStruct = new HeroStruct();LBStruct.name = "刘小备";LBStruct.weapon = "双刀";LBStruct.sex = "田力人";HeroClass GYClass = new HeroClass();GYClass.name = "关小羽";GYClass.weapon = "长龙宝刀";GYClass.sex = "公";Console.WriteLine(Environment.NewLine + "==========对象更改前==================");Console.WriteLine("LBStruct.name:&#123;0&#125;", LBStruct.name);Console.WriteLine("LBStruct.weapon:&#123;0&#125;", LBStruct.weapon);Console.WriteLine("LBStruct.sex:&#123;0&#125;", LBStruct.sex);Console.WriteLine();Console.WriteLine("GYClass.name:&#123;0&#125;", GYClass.name);Console.WriteLine("GYClass.weapon:&#123;0&#125;", GYClass.weapon);Console.WriteLine("GYClass.sex:&#123;0&#125;", GYClass.sex);HeroStruct CaoCao = LBStruct;CaoCao.name = "曹小操";CaoCao.weapon = "钢刀";CaoCao.sex = "汗子";HeroClass ZFClass = GYClass;ZFClass.name = "张小飞";ZFClass.weapon = "小斧子";ZFClass.sex = "小男人";Console.WriteLine(Environment.NewLine + "==========对象更改后==================");Console.WriteLine("CaoCao.name:&#123;0&#125;", CaoCao.name);Console.WriteLine("CaoCao.weapon:&#123;0&#125;", CaoCao.weapon);Console.WriteLine("CaoCao.sex:&#123;0&#125;", CaoCao.sex);Console.WriteLine();Console.WriteLine("ZFClass.name:&#123;0&#125;", ZFClass.name);Console.WriteLine("ZFClass.weapon:&#123;0&#125;", ZFClass.weapon);Console.WriteLine("ZFClass.sex:&#123;0&#125;", ZFClass.sex);Console.WriteLine(Environment.NewLine + "==========看一看之前对象==================");Console.WriteLine("LBStruct.name:&#123;0&#125;", LBStruct.name);Console.WriteLine("LBStruct.weapon:&#123;0&#125;", LBStruct.weapon);Console.WriteLine("LBStruct.sex:&#123;0&#125;", LBStruct.sex);Console.WriteLine();Console.WriteLine("GYClass.name:&#123;0&#125;", GYClass.name);Console.WriteLine("GYClass.weapon:&#123;0&#125;", GYClass.weapon);Console.WriteLine("GYClass.sex:&#123;0&#125;", GYClass.sex); 结果：1234567891011121314151617181920212223242526==========对象更改前==================LBStruct.name:刘小备LBStruct.weapon:双刀LBStruct.sex:田力人GYClass.name:关小羽GYClass.weapon:长龙宝刀GYClass.sex:公==========对象更改后==================CaoCao.name:曹小操CaoCao.weapon:钢刀CaoCao.sex:汗子ZFClass.name:张小飞ZFClass.weapon:小斧子ZFClass.sex:小男人==========看一看之前对象==================LBStruct.name:刘小备LBStruct.weapon:双刀LBStruct.sex:田力人GYClass.name:张小飞GYClass.weapon:小斧子GYClass.sex:小男人]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>值类型与引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 结构体(Struct)]]></title>
    <url>%2F2018%2F11%2F26%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[在C#中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct关键字用于创建结构体。结构体是用来代表一个记录。在C#中，结构体是值类型。类是引用类型。 12345678910111213struct HeroStruct&#123; public string name; public string weapon; public string sex;&#125;class HeroClass&#123; public string name; public string weapon; public string sex;&#125; 调用：1234567891011121314151617HeroStruct heroStruct = new HeroStruct();heroStruct.name = "黄忠";heroStruct.weapon = "大炮";heroStruct.sex = "爷们";HeroClass heroClass = new HeroClass();heroClass.name = "亚瑟";heroClass.weapon = "铁剑";heroClass.sex = "西洋汉子";Console.WriteLine("heroStruct.name =&#123;0&#125;", heroStruct.name);Console.WriteLine("heroStruct.weapon =&#123;0&#125;", heroStruct.weapon);Console.WriteLine("heroStruct.sex =&#123;0&#125;", heroStruct.sex);Console.WriteLine("heroClass.name =&#123;0&#125;", heroClass.name);Console.WriteLine("heroClass.weapon =&#123;0&#125;", heroClass.weapon);Console.WriteLine("heroClass.sex =&#123;0&#125;", heroClass.sex); 结果：123456heroStruct.name =黄忠heroStruct.weapon =大炮heroStruct.sex =爷们heroClass.name =亚瑟heroClass.weapon =铁剑heroClass.sex =西洋汉子 C#结构特点 结构可带有方法、字段、索引、属性、运算符方法和事件。 结构可定义构造函数，但不能定义析构函数。但是不能为结构定义默认的构造函数（无参）。默认的构造函数是自动定义的，且不能被改变。 与类不同，结构不能继承其它的结构或类。 结构不能作为其它结构或类的基础结构。 结构可实现一个或多个接口。 结构成员不能指定为abstract、virtual或protected。 当使用New操作符创建一个结构对象时，会调用适当的构函数创建结构。与类不同，结构可以不使用New操作符即可被实例化。 如果不使用New操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。 类 vs 结构类和结构不同点 类是引用类型，结构是值类型。 结构不支持继承。 结构不能声明默认的构造函数。 1234567891011121314151617181920212223 struct Books&#123; private string title; private string author; private string subject; private int book_id; public void getValues(string t, string a, string s, int id) &#123; title = t; author = a; subject = s; book_id = id; &#125; public void display() &#123; Console.WriteLine("Title:&#123;0&#125;",title); Console.WriteLine("Author:&#123;0&#125;",author); Console.WriteLine("Subject:&#123;0&#125;",subject); Console.WriteLine("Book_Id:&#123;0&#125;",book_id); &#125;&#125; 调用： 1234567Books book1 = new Books();Books book2 = new Books();book1.getValues("C#入门到放弃", "WPT", "C_Shap", 001);book2.getValues("C#放弃到种地", "WPT", "C_Shap", 002);book1.display();book2.display(); 结果： 12345678Title:C#入门到放弃Author:WPTSubject:C_ShapBook_Id:1Title:C#放弃到种地Author:WPTSubject:C_ShapBook_Id:2 注意： 在结构体中可以声明字段，但是声明字段是不能给初始值。 什么时候使用struct?结构存储在栈上，占用空间小，但访问速度快，而类存储在堆上，占用空间大，访问速度慢。 如果对象是一个轻量级的话，可以将其定义为结构。 对象拷贝时可以用结构。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>结构体(Struct)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 浅拷贝与深拷贝]]></title>
    <url>%2F2018%2F11%2F18%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[定义浅拷贝：将对象中的所有字段复制到新的副本对象中； 浅拷贝对于值类型与引用类型的方式区别值类型字段的值被复制到副本后，在副本中修改不会影响源对象对应的值；引用类型的字段的值被复制到副本后是引用类型的引用，而不是引用对象，在副本中对引用类型的字段值被修改后，源对象的值也将会被修改。 深拷贝：同样是将对象中的所有字段复制到副本对象中，但是，无论对象的值类型字段或者引用类型字段，都会被重新创建并复制，对于副本的修改，不会影响源对象的本身。 拷贝用到的类要继承ICloneable接口,ICloneable接口提供了Clone的方法， 示例如果： 1234567891011121314151617181920212223242526272829303132public class hero : ICloneable&#123; public string name &#123; get; set; &#125; public int grade &#123; get; set; &#125; public heroSkill hs &#123; get; set; &#125; public object Clone() &#123; return this.MemberwiseClone(); &#125;&#125;public class heroSkill&#123; public string name &#123; get; set; &#125; public int grade &#123; get; set; &#125; public heroSkill(string name,int grade) &#123; this.name = name; this.grade = grade; if(grade &gt;= 4) &#123; Console.WriteLine("开炮啊！！"); &#125;else &#123; Console.WriteLine("慢慢发育！！"); &#125; &#125; public override string ToString() &#123; return this.name; &#125;&#125; 调用如下： 123456789101112131415161718192021222324252627Console.WriteLine("==================黄忠属性============================");hero huangZhong = new hero()&#123; name = "黄忠", grade = 4, hs = new heroSkill("黄忠", 4)&#125;;Console.WriteLine(hzSon.name);Console.WriteLine(hzSon.grade);Console.WriteLine(hzSon.hs.ToString());Console.WriteLine("==================小黄忠属性【浅拷贝】============================");hero hzSon = huangZhong.Clone() as hero; Console.WriteLine(hzSon.name);Console.WriteLine(hzSon.grade);Console.WriteLine(hzSon.hs.ToString());Console.WriteLine("==================改变黄忠属性【浅拷贝】============================");huangZhong.name = "黄忠儿子";huangZhong.grade = 2;huangZhong.hs.name = "小黄忠";Console.WriteLine(hzSon.name);Console.WriteLine(hzSon.grade);Console.WriteLine(hzSon.hs.ToString()); 输出结果：12345678910111213==================黄忠属性============================开炮啊！！黄忠4黄忠==================小黄忠属性【浅拷贝】============================黄忠4黄忠==================改变黄忠属性【浅拷贝】============================黄忠4小黄忠 注意：ICloneable接口： 支持克隆，即用与现有实例相同的值创建类的新实例。【官方】，也就是如果要想克隆就要继承它.MemberwiseClone:创建当前 System.Object 的浅表副本。【官方】，也就是调用Clone方法。 由上面可见虽然改变了huangZhong.name值，但结果没有改变，可见string类型别然是引用类型，但是.net把string做为值类型来处理了。 因为hero中的heroSkill是引用类型，所以在huangZhong中的heroSkill的name改变，hzSon也相应的改变了。 对象的深拷贝两种方式： 创建一个对象，然后手动诼个赋值。 使用序列化方式进行深拷贝。 诼个赋值123456789101112131415161718192021Console.WriteLine("==================黄忠二儿子属性【深拷贝诼个赋值】============================");hero hzSon2 = new hero();hzSon2.name = huangZhong.name;hzSon2.grade = huangZhong.grade;hzSon2.hs = new heroSkill(huangZhong.hs.name,huangZhong.hs.grade);Console.WriteLine(hzSon2.name);Console.WriteLine(hzSon2.grade);Console.WriteLine(hzSon2.hs.ToString());Console.WriteLine("==================改变黄忠属性【深拷贝诼个赋值】============================");huangZhong.name = "黄忠儿子";huangZhong.grade = 2;huangZhong.hs.name = "小黄忠";Console.WriteLine(hzSon2.name);Console.WriteLine(hzSon2.grade);Console.WriteLine(hzSon2.hs.ToString()); 结果：123456789==================黄忠二儿子属性【深拷贝诼个赋值】============================开炮啊！！黄忠4黄忠==================改变黄忠属性【深拷贝诼个赋值】============================黄忠4黄忠 序例化代码：12345678910111213141516171819202122232425262728293031323334[Serializable]public class Student : ICloneable&#123; public string IDCode &#123; get; set; &#125; public int Age &#123; get; set; &#125; public Grent Grent &#123; get; set; &#125; public Student DeepClone() &#123; using (Stream objectStream = new MemoryStream()) &#123; IFormatter formatter = new BinaryFormatter(); formatter.Serialize(objectStream, this); objectStream.Seek(0, SeekOrigin.Begin); return formatter.Deserialize(objectStream) as Student; &#125; &#125; public object Clone() &#123; return this.MemberwiseClone(); //throw new NotImplementedException(); &#125;&#125;[Serializable]public class Grent&#123; public string Name &#123; get; set; &#125; public override string ToString() &#123; return this.Name; &#125;&#125; 调用： 12345678910111213141516Console.WriteLine("==================改变黄忠属性【深拷贝序列化】============================");hero hzSon3 = huangZhong.deepClone();Console.WriteLine(hzSon3.name);Console.WriteLine(hzSon3.grade);Console.WriteLine(hzSon3.hs.ToString());Console.WriteLine("==================改变黄忠属性【深拷贝序列化】============================");huangZhong.name = "黄忠儿子";huangZhong.grade = 3;huangZhong.hs.name = "小黄忠";Console.WriteLine(hzSon3.name);Console.WriteLine(hzSon3.grade);Console.WriteLine(hzSon3.hs.ToString()); 结果： 12345678==================改变黄忠属性【深拷贝序列化】============================黄忠4黄忠==================改变黄忠属性【深拷贝序列化】============================黄忠4黄忠]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>浅拷贝与深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——代码语法高亮]]></title>
    <url>%2F2018%2F11%2F07%2FMarkDown%2F11%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[为了方便文章代码阅读，需要将代码高亮显示。 语法：123&apos;&apos;&apos; 语言&apos;&apos;&apos; 注意 C#语言要使用cs，估计是C#中#是关键字吧 下面整理列出其它语言： 语言 关键字 1C 1c ActionScript actionscript Apache apache AppleScript applescript AsciiDoc asciidoc AspectJ asciidoc AutoHotkey autohotkey AVR Assembler avrasm Axapta axapta Bash bash BrainFuck brainfuck Cap’n Proto capnproto Clojure REPL clojure Clojure clojure CMake cmake CoffeeScript coffeescript C++ cpp C# cs CSS css D d Dart d Delphi delphi Diff diff Django django DOS.bat dos Dust dust Elixir elixir ERB(Embedded Ruby) erb Erlang REPL erlang-repl Erlang erlang FIX fix F# fsharp G-code(ISO 6983) gcode Gherkin gherkin GLSL glsl Go go Gradle gradle Groovy groovy Haml haml Handlebars handlebars Haskell haskell Haxe haxe HTML html HTTP http Ini file ini Java java JavaScript javascript JSON json Lasso lasso Less less Lisp lisp LiveCode livecodeserver LiveScript livescript Lua lua Makefile makefile Markdown markdown Mathematica mathematica Matlab matlab MEL (Maya Embedded Language) mel Mercury mercury Mizar mizar Monkey monkey Nginx nginx Nimrod nimrod Nix nix NSIS nsis Objective C objectivec OCaml ocaml Oxygene oxygene Parser 3 parser3 Perl perl PHP php PowerShell powershell Processing processing Python’s profiler output profile Protocol Buffers protobuf Puppet puppet Python python Q q R r RenderMan RIB rib Roboconf roboconf RenderMan RSL rsl Ruby ruby Oracle Rules Language ruleslanguage Rust rust Scala scala Scheme scheme Scilab scilab SCSS scss Smali smali SmallTalk smalltalk SML sml SQL sql Stata stata STEP Part21(ISO 10303-21) step21 Stylus stylus Swift swift Tcl tcl Tex tex text text/plain Thrift thrift Twig twig TypeScript typescript Vala vala VB.NET vbnet VBScript in HTML vbscript-html VBScript vbscript Verilog verilog VHDL vhdl Vim Script vim Intel x86 Assembly x86asm XL xl XML xml YAML yml]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>代码语法高亮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 静态类]]></title>
    <url>%2F2018%2F11%2F06%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E9%9D%99%E6%80%81%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、定义：静态类基本上与非静态类相同，但存在一个差异：静态类无法实例化。换句话说，无法使用new关键字创建类型的变量。由于不存在任何实例变量，因此可以使用类名本身访问静态类的成员。例如，如果你具有一个静态类，该类名为 UtilityClass，并且具有一个名为 MethodA 的公共方法，如下面的示例所示：12UtilityClass.MethodA(); ` 静态类可以用作只对输入参数进行操作并且不必获取或设置任何内部实例字段的方法集的方便容器。例如，在.Net Framework类库中，静态System.Math类包括执行数学运算，不用在意方法内部的实现，即，通过指定类名和方法名称来应用类的成员，如下面：1234double dub = -3.14;Console.WriteLine(Math.Abs(dub));Console.WriteLine(Math.Floor(dub));Console.WriteLine(Math.Round(dub)); 结果1233.14-4-3 静态类静态类功能： 只包含静态成员 无法进行实例化 会进行密封 不能包含实例构造函数 因此，创建静态类基本上与创建只包含静态成员和私有构造函数相同。私有构造函数可防止类进行实例化。静态类会进行密封，因些不能继承。它不能继承自任何类（除了Object）。静态类不能包含实例构造函数;但是，可以包含静态构造函数。 静态类代码： 1234567public static class MathEx&#123; public static string toString(double value) &#123; return value.ToString(); &#125; &#125; 调用代码：12string mathString = MathEx.toString(3.1415926585);Console.WriteLine(mathString); 调用结果：13.1415926585 静态成员非静态类可以包含静态方法、字段、属性、事件。即使未创建类的任何实例，也可对类调用静态成员。静态成员始终按类名（而不是实例名称）进行访问。静态成员只有一个副本存在（与创建的类的实例数有关）。静态方法和静态属性无法访问其类中的静态属性和方法。 静态方法可以进行重载，但不能进行替代，因为它们属性于类，而不属于类的任何实例。虽然字段不能声明为 static const，不过const字段在其行为方面本质是静态的。使用与静态属性字段相同。无需把对象实例化。 非静态类中的静态类与静态字段，代码：12345678910111213141516public class MathTest&#123; public static string YW = "112"; public string SX = "120"; public const string SL = "250"; public static string SayYW() &#123; return MathTest.YW; &#125; public string SaySX() &#123; return this.SX; &#125;&#125; 调用代码：123456string sayYW = MathTest.SayYW();Console.WriteLine("语文:&#123;0&#125;", sayYW);MathTest mt = new MathTest();string saySX = mt.SaySX();Console.WriteLine("数学：&#123;0&#125;",saySX);Console.WriteLine(MathTest.SL); 调用结果： 123语文:112数学：120250 静态方法与非静态方法的比较一、使用stati修饰的方法是静态方法，否则就是非静态方法。二、差异比较：静态字段： 静态成员属于类所有，非静态成员属于类实例所有。 每创建一个类的实例，都会在内存中为非静态成员新分配存储空间总结：静态成员属于类所有，为各个类的实例所公用，无论类创建了多少实例，类的静态成员在内存中只占一块。静态方法： 静态方法属于类所有，类实例化前即可使用。 非静态方法可以访问类中任何成员，静态方法只能访问类中的静态成员。 静态方法可以使用静态变量，无法使用非静态变量。静态方法在类的实例化前已经确定好存储位置。 总结：静态方法是一种特殊的成员方法，这不属于类的某一个具体实例，而是属于类本身。所以对于静态方法不需要实例化，而是采用 类名.静态方法的格式。 注意： static不能用 this同时使用 静态方法效率比非静态方法效率高，但静态方法不能自动销毁，而实例化方法可以销毁。 静态方法和静态字段创建后使用同一块内在，而实例化的方式会创建多个内存。 C#中的方法有两种：实例方法、静态方法。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>静态类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 密封类]]></title>
    <url>%2F2018%2F11%2F06%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%AF%86%E5%B0%81%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、定义：官方： 通过在类定义前面放置关键字 sealed,可以将类声明为密封类。例如：123public sealed class D&#123;&#125; 密封类不能用作基类。因此，它不能是抽象类，密封类禁止派生。由于密封类从不用作基类，所以有些运行时优化可以略微提高密封类成员的调用速度。 在对基类的虚成员进行重写的派生类上，方法、索引器、属性事件可以将该成员声明为密封成员。在用于以后的派生类时，这将取消成员的虚效果。方法是在类成员声明中将sealed关键字置于override关键字前面。例如：1234public class D:C&#123; public sealed override void DoWork()&#123;&#125;&#125; 自定义： 如果我们不希望自己编写的类被继承; 如果有的类已经没有再被继承的必要这时，我们可以使用sealed修饰符在类中进行声明，以达到该类不能派生其它类的目的，该类就被称为密封类。 密封类不能同时又是抽象类，因为密封类不能用作基类、也不能被继承，而抽象类总是希望被继承的。 描述：密封类可以用来限制扩展性，如果密封了某个类，则其他类不能从该类继承，如果密封了某个成员，则派生类不能重写该成员的实现。默认情况下，不应密封类型和成员。密封可以防止对库的类型和成员进行自定义，但也会影响某些开发人员对可用性的认识。 C# 中使用密封类时，如果类满足如下条件，则应将其密封。 类是静态类。 类包含带有安全信息的继承的受保护成员。 类继承多个虚成员，并且密封每个成员的开发和测试开销明显大于密封整个类。 类是一个要求使用反射进行快速搜索的属性。密封属性可提高反射在检索属性时的性能。 说明： 密封类不能作为基类被继承，但可以继承别的类或接口。 在密封类中不能声明受保护成员或虚成员，因为受保护成员只能从派生类进行访问，而虚成员只能在派生类中重写。 由于密封类的不可继承性，因此密封类不能声明为抽象的，即sealed修饰符不能与abstract修饰符同时使用。 二、示例 密封类例：下面代码声明一个密封类，该密封类中包含一个Int类型的变量和一个返回值类型方法，它们只能通过实例化密封类的对象来访问，而不能被继承。代码如下：1234567891011121314151617public sealed class moneyClass&#123; public int amount = 0 ; public void buyCar() &#123; if(amount &gt; 200000) &#123; Console.WriteLine(&quot;可以买车啦！！&quot;); &#125; else &#123; Console.WriteLine(&quot;好好工作吧！！&quot;); &#125; &#125;&#125; 调用密封类：123moneyClass mc = new moneyClass();mc.amount = 1000000;mc.buyCar(); 结果：1可以买车啦！！ 密封方法并不是每个方法都可以声明为密封方法，密封方法只能用于对基类的虚方法进行实现，并提供具体的实现，所以声明密封方法时，sealed修饰符总是和override修饰符同时使用。 代码：123456789101112131415public class person&#123; public virtual void say() &#123; Console.WriteLine(&quot;我是人类的总称&quot;); &#125;&#125;public sealed class Chinese:person&#123; public sealed override void say() &#123; base.say(); Console.WriteLine(&quot;我是中国人啊！！！&quot;); &#125;&#125; 调用代码：12Chinese cn = new Chinese();cn.say(); 调用结果：12我是人类的总称我是中国人啊！！！ 密封类与密封方法的使用密封类除了不能被继承外，与非密封类的用法大致相同，而密封方法则必须通过重写基类中的虚方法来实现代码：12345678910111213141516public class person&#123; public virtual void say() &#123; Console.WriteLine(&quot;我是人类的总称&quot;); &#125;&#125;public sealed class Chinese:person&#123; public string name = &quot;&quot;; public sealed override void say() &#123; base.say(); Console.WriteLine(&quot;我的名子是：&#123;0&#125;&quot;,name); &#125;&#125; 调用代码：123Chinese cn = new Chinese();cn.name = &quot;二蛋&quot;;cn.say(); 调用结果：12我是人类的总称我的名子是：二蛋 总结：密闭类是修饰为sealed的类，sealed 不能有子类。一般只有系统中的一些基本类声明为sealed。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>密封类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引器]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E7%B4%A2%E5%BC%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[定义官方定义：索引器允许类或结构的实例就像数组一样进索引。无需显式指定类型或实例成员，即可设置或检索索引值。索引器类似于属性，不同之处在于它们的访问器需要使用参数。 码友定义： 索引器允许类或者结构的实例按照与数组的方式进行索引取值，不同的是索引器的访问是带参数的。 索引器是一种特殊的类成员，它能够让对象以类似数组的方式来存取。 下面来定义一泛型类： 123456789101112131415161718public class SampleCollection&lt;W&gt;&#123; /// &lt;summary&gt; /// 声明一个数据用于存储数据元素 /// &lt;/summary&gt; private W[] arr = new W[100]; /// &lt;summary&gt; /// 定义一个索引器允许客户端代码 /// &lt;/summary&gt; /// &lt;param name=&quot;i&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public W this[int i] &#123; get &#123; return arr[i]; &#125; set &#123; arr[i] = value; &#125; &#125;&#125; 主程序调用：123var stringCollection = new SampleCollection&lt;string&gt;();stringCollection[0] = &quot;Hello World!!&quot;;Console.WriteLine(stringCollection[0]); 使用索引器示例一：用数字索引索引器代码：1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 使用数字索引/// &lt;/summary&gt;public class TempRecord&#123; // 定义 private string[] temps = new string[10] &#123; &quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;七&quot;,&quot;八&quot;,&quot;九&quot;,&quot;十&quot; &#125;; public int Lenght &#123; get &#123; return temps.Length; &#125; &#125; public string this[int index] &#123; get &#123; return temps[index]; &#125; set &#123; temps[index] = value; &#125; &#125;&#125; 调用代码：12345678TempRecord tR = new TempRecord();tR[3] = &quot;叁&quot;;tR[5] = &quot;伍&quot;;for(int i = 0; i&lt;10; i++)&#123; Console.WriteLine(&quot;&#123;0&#125; ====》》》&#123;1&#125;&quot;, i, tR[i]);&#125; 结果：1234567891011Hi Index0 ====》》》一1 ====》》》二2 ====》》》三3 ====》》》叁4 ====》》》五5 ====》》》伍6 ====》》》七7 ====》》》八8 ====》》》九9 ====》》》十 示例二： 使用字符串索引索引器代码：1234567891011121314151617181920212223242526272829303132333435public class DayCollection&#123; // 一个周 string[] days = &#123; &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tues&quot;, &quot;Thurs&quot;, &quot;Fri&quot;, &quot;Sat&quot; &#125;; /// &lt;summary&gt; /// 对比输入的日期，如果是目的就输入 /// &lt;/summary&gt; /// &lt;param name=&quot;testDay&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private int GetDay(string testDay) &#123; for(int j = 0; j &lt; days.Length; j++) &#123; if(days[j] == testDay) &#123; return j; &#125; &#125; throw new ArgumentOutOfRangeException(testDay, &quot;搞错了吧！！&quot;); &#125; /// &lt;summary&gt; /// 只读索引器 /// &lt;/summary&gt; /// &lt;param name=&quot;day&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int this[string day] &#123; get &#123; return (GetDay(day)); &#125; &#125;&#125; 调用代码：12DayCollection dc = new DayCollection();Console.WriteLine(dc[&quot;Tues&quot;]); 调用结果：12 示例三：多个索引器参数代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CoordCollectiion&#123; /// &lt;summary&gt; /// 存储数据的容器 /// &lt;/summary&gt; Dictionary&lt;string, int[]&gt; dicArr = new Dictionary&lt;string, int[]&gt;(); /// &lt;summary&gt; /// 存储数据 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int this[string name ,int x, int y] &#123; // 虽然没用，但还是要留用 get &#123; return 1; &#125; set &#123; int[] intVlaue = &#123; x, y &#125;; // listArr.Add(intVlaue); dicArr.Add(name, intVlaue); &#125; &#125; /// &lt;summary&gt; /// 取数据 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int[] this[string name] &#123; get &#123; bool bContain = dicArr.ContainsKey(name); if (bContain) &#123; return dicArr[name]; &#125; throw new Exception(&quot;没找到对应数据!!&quot;); &#125; &#125;&#125; 调用代码： 1234/// 重载索引器CoordCollectiion cc = new CoordCollectiion();int a = cc[&quot;one&quot;, 111, 222];int b = cc[&quot;two&quot;, 222, 333];]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>索引器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppSettings和ConnectionStrings的区别]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2FAppSettings%E5%92%8CConnectionStrings%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[三种配置文件 web.config是web应用程序的配置文件，为web应用程序担相应配置（B/S）。 app.config是桌面端应用程序的配置文件，为桌面应用程序提供相应配置文件。 AppSettings是ASP.Net1.1时期用的。ConnectionStrings是.Net Framework 2.0 新增的 一、 connectionStrings]以下是App.config配置： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5.2&quot; /&gt; &lt;/startup&gt; &lt;connectionStrings&gt; &lt;add name=&quot;ConnStrHello&quot; connectionString=&quot;Data Source=LEIKE;Initial Catalog=SYXT;User ID=sa;Password=sa&quot; providerName=&quot;System.Data.SqlClient&quot; /&gt; &lt;/connectionStrings&gt;&lt;/configuration&gt; 以下是主应用程序调用示例： 123456789101112131415161718using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string cs = ConfigurationManager.ConnectionStrings[&quot;ConnStrHello&quot;].ConnectionString; Console.ReadKey(); &#125; &#125;&#125; 二、 appSettings以下为App.config配置内容： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5.2&quot; /&gt; &lt;/startup&gt; &lt;appSettings&gt; &lt;add key=&quot;mobile&quot; value =&quot;10085&quot;/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 以下为主应用程序调用示例：12345678910111213141516171819using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string sys = ConfigurationManager.AppSettings[&quot;mobile&quot;]; Console.Write(sys); Console.ReadKey(); &#125; &#125;&#125; 三、区别 AppSettings 是在2003中常用的，ConnectionStrins是2005中常用的. 使用ConnectionString的好处： 第一：可将连接字符串加密，使用MS的一个加密工具即可。 第二：可直接邦定的数据源控件，而不必写代码读出来再赋值给控件。 第三：可方便的更换数据库平台，如换为Oracle数据库，只需修改providerName。 写在 中用System.Configuration.ConfigurationManager.AppSettings[“name”]检索值。写在 中用System.Configuration.ConfigurationManager.ConnectionStrings[“name”]检索值。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>AppSettings</tag>
        <tag>ConnectionStrings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项目开发]]></title>
    <url>%2F2018%2F11%2F01%2FRPCShap%2F01%E5%90%84%E7%A7%8D%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在一个项目发开中经常会将通用的方法单独封装成一个类库，供其它项目使用，其它项目使用时有两种引用方式。 引用库文件。 直接引用项目文件。 因引用库文件无法随着代码的更新而更改，所以推荐引用项目。 一、新建工程如图： 其中”WPTClient”为开发项目，”WpTLibs”为项目引用类库。 WPTClient代码如下： 12345678910111213141516171819using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTClient&#123; class Program &#123; static void Main(string[] args) &#123; string s = &quot;wpt@wpt.com&quot;; Console.Write(WPTLibs.Helper.IsEmail(s)); Console.ReadKey(); &#125; &#125;&#125; WPTLibs的代码如下： 12345678910111213141516using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WPTLibs&#123; public class Helper &#123; public static bool IsEmail(string s) &#123; return s.Contains(&quot;@&quot;); &#125; &#125;&#125; 二、项目引用“WPTClient” &gt;&gt; “引用” &gt;&gt; “添加引用” &gt;&gt; “项目” &gt;&gt; “解决方案” &gt;&gt; “WPTLibs”]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>多项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法标题]]></title>
    <url>%2F2018%2F10%2F24%2FMarkDown%2F00%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[markdown是一种纯文本格式的标记语言。通过简单的标记语法，可以使普通文本内容具有一定的格式。]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>标题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——流程图]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F10%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[示例：12345678910&apos;&apos;&apos;flowst=&gt;start: 黄忠op=&gt;operation: 重装炮台cond=&gt;condition: penta kill ?e=&gt;end: victoryst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&apos;&apos;&apos; 说明: st 是变量名 start是操作名 黄忠是显示的文本 效果： 可用模块 开始 startst=&gt;start: 开始 结束 ende=&gt;end: 结束 普通操作块 oprationop1=&gt;opration: 第一个操作op2=&gt;opration: 第二个操作 判断块 conditioncond1=&gt;condition: 第一个判断cond2=&gt;condition: 第二个判断 输入输出块 inputoutputio1=&gt;inputoutput: 输入输出块1io2=&gt;inputoutput: 输入输出块2 子任务块sub1=&gt;subroutine: 子任务1sub2=&gt;subroutine: 子任务2 判断与位置控制 判断流程控制con1(yes)-&gt;op1 #yes 的时候回到 op1con1(no)-&gt;e #no 的时候到结束 位置指定cond1(no)-&gt;op2(right)-&gt;op1 #控制 op2 位置置于右边，再由op2 返回 op1#还可以这样 cond1(no,right)cond1(yes)-&gt;e 示例：1234567891011&apos;&apos;&apos;flow st=&gt;start: 黄忠op1=&gt;operation: 警戒地雷cond=&gt;condition: 没有敌人 ？op2=&gt;operation: 追击潜能e=&gt;end: 摧塔 st-&gt;op1-&gt;condcond(no)-&gt;op2(right)-&gt;op1cond(yes)-&gt;e&apos;&apos;&apos; 效果： 流程控制12345678910st-&gt;op1-&gt;e# -&gt; 作为控制流程的操作符，就是指向下一步要操作。# 每一条都算是一条流程# 可以断开写也可以合着写#分开写st-&gt;op1op1-&gt;e#合着写st-&gt;op1-&gt;e 示例一代码1234567&apos;&apos;&apos;st=&gt;start: 黄忠op=&gt;operation: 重装炮台e=&gt;end: victoryst-&gt;op-&gt;e&apos;&apos;&apos; 效果 示例二12345678&apos;&apos;&apos;cond=&gt;condition: 七杀？op=&gt;operation: 继续杀io=&gt;inputoutput: 你已超神！！cond(yes)-&gt;iocond(no)-&gt;op&apos;&apos;&apos; st=>start: 黄忠 op=>operation: 重装炮台 cond=>condition: penta kill ? e=>end: victory st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 黄忠 op1=>operation: 警戒地雷 cond=>condition: 没有敌人 ？ op2=>operation: 追击潜能 e=>end: 摧塔 st->op1->cond cond(no)->op2(right)->op1 cond(yes)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);st=>start: 黄忠 op=>operation: 重装炮台 e=>end: victory st->op->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-2-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-2", options);cond=>condition: 七杀？ op=>operation: 继续杀 io=>inputoutput: 你已超神！！ cond(yes)->io cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-3-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-3", options);]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——代码]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F09%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[单行代码语法将代码包涵于 ` `之间 示例`这是单行代码 Hello World;` 效果这是单行代码 Hello World; 代码块语法代码之间分别用三个反引号包起来，且两边反引号单独占一行 示例\1234function()&#123; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; console.log(&quot;OKKK啊！！&quot;); &#125; \ 效果123function()&#123; console.log(&quot;OKKK啊！！&quot;); &#125;]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——表格]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F08%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[语法 第一行为表头，第二行分隔表头与表内容，第三行及以后为表内容。 列与列之间用‘|’隔开。 第二行指定对齐方式，默认为左对齐，在‘-’右边加上’:’为右对齐 示例12345姓名|技能|排行---|:--:|---:张三|宝刀|老一李四|大刀|老二王五|菜刀|老末 效果 姓名 技能 排行 张三 宝刀 老一 李四 大刀 老二 王五 菜刀 老末]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——列表]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F07%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[无序列表语法无序列表可以用-,+,= 示例：123456- 列表内容-- 列表内容-+ 列表内容++ 列表内容+* 列表内容** 列表内容* 效果： 列表内容- 列表内容- 列表内容+ 列表内容+ 列表内容* 列表内容* 有序列表语法：数字加点 示例：1231. 列表内容12. 列表内容23. 列表内容3 效果： 列表内容1 列表内容2 列表内容3 列表嵌套:语法：上一级和下一级空三个空格 示例：12345678910111213141516- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容- 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 效果： 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——超链接]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F06%E8%B6%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[超链接格式其实与图片的格式差不多 语法[超链接名](超链接地址 &quot;超链接title&quot;)title 可以不加 示例12[谷歌](http://www.google.cn/ &quot;谷歌&quot;)[百度](http://www.baidu.com/ &quot;百度&quot;) 谷歌百度]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>超链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——图片]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F05%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[语法![图片alt](图片地址 &quot;图片title&quot;) 图片alt：图片下面的文字，相当于对文字的解释。屁的我试了没有用，显示的是图片title。图片的titile:图片的标题，当鼠标移动时图片时显示内容。title可以不加。 示例![无处安放](TIM图片20180824154454.jpg &quot;愿安好！！&quot;) 效果 题外话解决如果无法显示图片： 把主体配置文件_config.yml里的 post_asset_folder: false改为true。 在hexo目录下执行npm install hexo-asset-image --save，安装这个插件。]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——分割线]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F04%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[分割线有两个实现方式：1、三个或者三个以上 -三个- --- 三个以上- ---- 2、三个或者三个以上 *三个* *** 三个以上* ****]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>分割线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——引用]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F03%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在引用的文字前加&gt; 就可以了如： 123&gt; 这是引用的内容&gt; &gt; 这是引用的内容&gt; &gt; &gt; &gt; &gt; &gt; &gt; 这是引用的内容 这是引用的内容 这是引用的内容 这是引用的内容]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——字体]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F02%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[加粗将要加粗的文字分别用两个**包起来就可了 快捷键 ctrl + B, 如： **这是加粗的文字**这是加粗的文字 加斜线将要加斜线的文字分别用两个*包起来就可了 快捷键 ctrl + I, 如： *这是倾斜的文字*这是倾斜的文字 既加粗又加斜线这面是既加粗又加斜线的用三个*包括起来 ***这是倾斜加粗的文字***这是倾斜加粗的文字 加删除线加删除线的用两个~~包括起来 ~~这是要加删除线的文字~~这是要加删除线的文字]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法——标题]]></title>
    <url>%2F2018%2F10%2F22%2FMarkDown%2F01%E6%A0%87%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在想要设置为标题的文字前面加#来表示，一个#代表一级标题，如： # 这是一级标题 这是一级标题 ## 这是二级标题 这是二级标题 ### 这是三级标题 这是三级标题 #### 这是四级标题 这是四级标题 ##### 这是五级标题 这是五级标题 ###### 这是六级标题 这是六级标题]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>标题</tag>
      </tags>
  </entry>
</search>
